@class NSObject, NSString, NSArray, CIFilter, SKTextureCache, SKTextureAtlas;
@protocol OS_dispatch_queue;

@interface SKTexture : NSObject <NSCopying, NSSecureCoding> {
    BOOL _shouldGenerateMipmaps;
    BOOL _didGenerateMipmaps;
    BOOL _isPath;
    BOOL _isData;
    NSString *_imgName;
    NSArray *_searchPaths;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _textRect;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _textCoords;
    BOOL _disableAlpha;
    BOOL _isRotated;
    BOOL _isFlipped;
    int _alignment;
    int _rowLength;
    CIFilter *_filter;
    SKTexture *_originalTexture;
    unsigned int _textureTarget;
    SKTextureCache *_textureCache;
    NSObject<OS_dispatch_queue> *_textureSyncQueue;
}

@property (class, readonly) BOOL supportsSecureCoding;

@property (readonly, nonatomic) struct CGSize { double x0; double x1; } pixelSize;
@property (nonatomic) unsigned int textureTarget;
@property (nonatomic) BOOL isRotated;
@property (nonatomic) BOOL isFlipped;
@property (readonly, nonatomic) BOOL hasAlpha;
@property (nonatomic) int wrapMode;
@property (readonly, nonatomic) NSString *imageNameOrPath;
@property BOOL performFullCapture;
@property (readonly, nonatomic) BOOL isRepeatable;
@property (nonatomic) struct CGPoint { double x; double y; } cropScale;
@property (nonatomic) struct CGPoint { double x; double y; } cropOffset;
@property (copy, nonatomic) NSString *originalAtlasName;
@property (retain, nonatomic) SKTextureAtlas *rootAtlas;
@property (copy, nonatomic) NSString *subTextureName;
@property (readonly, nonatomic) unsigned int *alphaMap;
@property (readonly, nonatomic) struct CGSize { double width; double height; } alphaMapSize;
@property (nonatomic, getter=_needsExtrusionWorkaround) BOOL needsExtrusionWorkaround;
@property (nonatomic) long long filteringMode;
@property (nonatomic) BOOL usesMipmaps;

+ (id)textureWithImage:(id)a0;
+ (void)preloadTextures:(id)a0 withCompletionHandler:(id /* block */)a1;
+ (id)textureWithData:(id)a0 size:(struct CGSize { double x0; double x1; })a1;
+ (id)_textureByTransferingData:(char *)a0 size:(struct CGSize { double x0; double x1; })a1;
+ (id)_textureWithImageNamed:(id)a0;
+ (id)textureWithImageNamed:(id)a0;
+ (id)textureWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 inTexture:(id)a1;
+ (id)preloadQueue;
+ (id)lookupTextureCacheForName:(id)a0;
+ (void)registerTextureCache:(id)a0 forName:(id)a1;
+ (id)textureWithCGImage:(struct CGImage { } *)a0 pointSize:(struct CGSize { double x0; double x1; })a1;
+ (id)textureWithImageNamed:(id)a0 rect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
+ (id)textureVectorNoiseWithSmoothness:(double)a0 size:(struct CGSize { double x0; double x1; })a1;
+ (id)textureNoiseWithSmoothness:(double)a0 size:(struct CGSize { double x0; double x1; })a1 grayscale:(BOOL)a2;
+ (id)textureWithCGImage:(struct CGImage { } *)a0;
+ (id)textureWithData:(id)a0 size:(struct CGSize { double x0; double x1; })a1 flipped:(BOOL)a2;
+ (id)textureWithData:(id)a0 size:(struct CGSize { double x0; double x1; })a1 rowLength:(unsigned int)a2 alignment:(unsigned int)a3;
+ (void)_reloadTextureCacheForImageNamed:(id)a0;
+ (id)_cachedTextureNames;
+ (id)compressedTextureWithData:(id)a0;
+ (id)compressedTextureWithData:(id)a0 size:(struct CGSize { double x0; double x1; })a1 bitsPerPixel:(unsigned int)a2 hasAlpha:(BOOL)a3;
+ (id)textureWithImagePath:(id)a0;
+ (id)_textureByTransferingData:(char *)a0 size:(struct CGSize { double x0; double x1; })a1 rowLength:(unsigned int)a2 alignment:(unsigned int)a3;
+ (id)_textureWithGLTextureId:(unsigned int)a0 size:(struct CGSize { double x0; double x1; })a1;
+ (id)textureWithIOSurfaceID:(unsigned int)a0 width:(unsigned int)a1 height:(unsigned int)a2 format:(unsigned int)a3;
+ (id)textureWithMetalTexture:(id)a0;

- (struct CGImage { } *)CGImage;
- (id)init;
- (void).cxx_destruct;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (void)commonInit;
- (void)dealloc;
- (struct CGSize { double x0; double x1; })size;
- (id)initWithCoder:(id)a0;
- (id)description;
- (id)_textureCache;
- (id)metalTexture;
- (id)imgName;
- (void)encodeWithCoder:(id)a0;
- (id)initWithImagePath:(id)a0;
- (void)preloadWithCompletionHandler:(id /* block */)a0;
- (int)glTextureId;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })textureRect;
- (struct shared_ptr<jet_texture> { struct jet_texture *x0; struct __shared_weak_count *x1; })_backingTexture;
- (struct CGImage { } *)_createCGImage;
- (id)textureByGeneratingNormalMapWithSmoothness:(double)a0 contrast:(double)a1;
- (id)_generateNormalMap:(double)a0 contrast:(double)a1 multiPass:(unsigned long long)a2;
- (BOOL)loadImageDataFromPVRData:(id)a0;
- (void)loadImageData;
- (void)initTextureCacheWithImageData;
- (void)_ensureImageData;
- (void)loadImageDataFromCGImage:(struct CGImage { } *)a0 pointsSize:(struct CGSize { double x0; double x1; })a1;
- (BOOL)loadImageDataFromPVRGZData:(id)a0;
- (id)_copyImageData;
- (id)initWithImageNamed:(id)a0;
- (id)textureByGeneratingNormalMap;
- (void)setTextureDimension:(const struct CGSize { double x0; double x1; } *)a0 withPixelSize:(const struct CGSize { double x0; double x1; } *)a1;
- (BOOL)isEqualToTexture:(id)a0;
- (id)textureByApplyingCIFilter:(id)a0;
- (id)initWithBackingTetxure:(struct shared_ptr<jet_texture> { struct jet_texture *x0; struct __shared_weak_count *x1; })a0 logicalWidth:(float)a1 height:(float)a2;
- (id)initWithBackingTetxure:(struct shared_ptr<jet_texture> { struct jet_texture *x0; struct __shared_weak_count *x1; })a0;
- (void)setIsData:(BOOL)a0;
- (id)_initWithGLTextureId:(unsigned int)a0 size:(struct CGSize { double x0; double x1; })a1;
- (struct CGImage { } *)_newTextureFromGLCache;
- (int)_convert_jet_texture_format_to_ci_format:(unsigned int)a0;
- (void)_setImageName:(id)a0;
- (void)_savePngFromGLCache:(id)a0;

@end
