@class PKStrokeGenerator, CAMetalLayer, NSMutableArray, NSArray, PKMetalRenderer, NSObject, PKLinedPaper;
@protocol MTLTexture, PKMetalRendererControllerDelegate, MTLDevice, CAMetalDrawable, OS_dispatch_semaphore, MTLCommandQueue, OS_dispatch_queue;

@interface PKMetalRendererController : NSObject <PKRendererVSyncControllerDelegate> {
    _Atomic int _cancelLongRunningRenderingCount;
    _Atomic int _cancelAllRendering;
    NSObject<OS_dispatch_semaphore> *_canBeginRenderSemaphore;
    struct atomic_flag { _Atomic BOOL _Value; } _readyToBeginRender;
    _Atomic double _lastFrameDuration;
    _Atomic unsigned long long _lastPresentationTime;
    _Atomic int _queuedRenders;
    NSMutableArray *_postPresentCallbacks;
    BOOL _isTorndown;
    long long _presentationCount;
    struct PKRunningStat { long long numValues; long long numValuesOverLimit; double oldM; double newM; double oldS; double newS; double minValue; double maxValue; double limit; struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } lock; } _strokeLatencyStat;
    struct PKRunningStat { long long numValues; long long numValuesOverLimit; double oldM; double newM; double oldS; double newS; double minValue; double maxValue; double limit; struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } lock; } _predictedTouchesLatencyStat;
    id<MTLTexture> _currentTextureTarget;
    id<CAMetalDrawable> _currentDrawable;
    struct CGImage { } *_paperTextureImage;
    struct CGPoint { double x; double y; } _canvasOffset;
    struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } _strokeTransformForRenderQueue;
    id /* block */ _canvasOffsetBlock;
    NSArray *_liveStrokeStrokes;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _liveStrokeStrokesAnimationBounds;
    BOOL _dirtyRectMightBeInvalid;
}

@property (retain, nonatomic) PKMetalRenderer *renderer;
@property struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } renderTransform;
@property double inputScale;
@property (nonatomic) double _latestLatency;
@property (weak, nonatomic) id<PKMetalRendererControllerDelegate> delegate;
@property (readonly, nonatomic) id<MTLCommandQueue> commandQueue;
@property (readonly, nonatomic) id<MTLDevice> device;
@property (readonly, nonatomic) unsigned long long pixelFormat;
@property (readonly, nonatomic) NSObject<OS_dispatch_queue> *renderQueue;
@property (nonatomic) struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } strokeTransform;
@property (readonly, nonatomic) PKStrokeGenerator *inputController;
@property (nonatomic) double backboardPaperMultiply;
@property (retain, nonatomic) PKLinedPaper *linedPaper;
@property (nonatomic) struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } viewScissor;
@property (nonatomic) struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } paperTransform;
@property (readonly, nonatomic) struct CGSize { double width; double height; } actualSize;
@property (readonly, nonatomic) struct CGSize { double width; double height; } pixelSize;
@property (nonatomic) BOOL liveStrokeMode;
@property (nonatomic) struct CGSize { double width; double height; } liveStrokeMaxSize;
@property (nonatomic) BOOL fadeOutStrokesMode;
@property (nonatomic) double liveStrokeElapsedTime;
@property (nonatomic) double liveStrokeDuration;
@property (weak, nonatomic) CAMetalLayer *presentationLayer;
@property (nonatomic) BOOL invertColors;

- (void)setup;
- (void)clear;
- (void)teardown;
- (void).cxx_destruct;
- (void)dealloc;
- (void)setBackgroundColor:(struct CGColor { } *)a0;
- (id)device;
- (id).cxx_construct;
- (id)initWithPixelSize:(struct CGSize { double x0; double x1; })a0 actualSize:(struct CGSize { double x0; double x1; })a1 renderQueue:(id)a2 usePrivateResourceHandler:(BOOL)a3 pixelFormat:(unsigned long long)a4;
- (void)cancelAllRendering;
- (void)cancelLongRunningRenders;
- (void)renderTiles:(id)a0 tileTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a1;
- (void)drawImage:(struct CGImage { } *)a0 andMask:(struct CGImage { } *)a1;
- (void)drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 useLayerContext:(BOOL)a3 completion:(id /* block */)a4;
- (void)drawImage:(struct CGImage { } *)a0 andMask:(struct CGImage { } *)a1 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2;
- (void)drawStrokes:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 completion:(id /* block */)a2;
- (void)drawStrokes:(id)a0 renderIntermediateSteps:(BOOL)a1 completion:(id /* block */)a2;
- (struct CGImage { } *)newCGImage;
- (void)flushMemoryIfPossible;
- (void)_copyIntoTilesFromRenderQueue:(id)a0 tileTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a1;
- (void)replaceInkTexture:(id)a0 image:(struct CGImage { } *)a1;
- (void)setPaperTextureImage:(struct CGImage { } *)a0;
- (void)setLiveRenderingOverrideColor:(struct CGColor { } *)a0;
- (void)setResourceCacheSize:(unsigned long long)a0;
- (void)setPixelSize:(struct CGSize { double x0; double x1; })a0 actualSize:(struct CGSize { double x0; double x1; })a1;
- (void)purgeOriginalBackFramebuffer;
- (void)purgeRenderCachesForStrokes:(id)a0;
- (void)setLiveStrokeStrokes:(id)a0 animationBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (void)setAlternativeStrokes:(id)a0 alpha:(double)a1 originalStrokeAlpha:(double)a2;
- (BOOL)prerenderWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 inputScale:(double)a1 at:(double)a2;
- (void)didFinishRendering:(id /* block */)a0;
- (void)changeRenderSize;
- (void)callBlockAfterPresenting:(id /* block */)a0;
- (void)setCanvasOffsetPresentationOffsetBlock:(id /* block */)a0;
- (void)drawingBeganWithStroke:(id)a0;
- (void)drawingEnded:(id)a0 finishStrokeBlock:(id /* block */)a1;
- (void)drawingCancelled;
- (void)drawingCancelledWithCompletion:(id /* block */)a0;
- (void)liveStrokeParticlesToFrame:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 strokes:(id)a1 startTime:(double)a2 duration:(double)a3;
- (void)setCanvasOffset:(struct CGPoint { double x0; double x1; })a0;
- (void)signalVSyncSemaphore:(double)a0 presentationTime:(unsigned long long)a1;
- (BOOL)isAllRenderingCancelled;
- (void)resumeLongRunningRenders;
- (void)setupSync;
- (unsigned long long)_drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 useLayerContext:(BOOL)a3 progress:(id)a4;
- (struct CGImage { } *)newCGImageWithClipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)_drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 useLayerContext:(BOOL)a3 renderCompletion:(id /* block */)a4;
- (void)buildRenderCacheForStrokes:(id)a0;
- (BOOL)isLongRunningRenderingCancelled;
- (void)_updateRendererStrokeTransformWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 offset:(struct CGPoint { double x0; double x1; })a1;
- (void)_renderAndPresent:(BOOL)a0 withTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a1;
- (BOOL)_setupCurrentDrawable;
- (void)_present:(double)a0 setDirtyRect:(BOOL)a1;
- (BOOL)_renderAheadWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 at:(double)a1;
- (void)_renderDrawPoints;
- (void)_renderLiveStrokeAndPresentWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 at:(double)a1 setDirtyRect:(BOOL)a2;
- (void)pokeEventDispatcher;
- (id)initWithPixelSize:(struct CGSize { double x0; double x1; })a0 actualSize:(struct CGSize { double x0; double x1; })a1 renderQueue:(id)a2 usePrivateResourceHandler:(BOOL)a3;
- (void)teardownSync;
- (void)resumeLongRunningRendersAfterAllWorkIsDone;
- (struct CGImage { } *)renderStrokesSync:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 imageClipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3;
- (void)renderStrokes:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 strokeTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a2 imageClipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3 completion:(id /* block */)a4;
- (BOOL)drawStrokes:(id)a0 intoTile:(id)a1 renderCount:(long long)a2;
- (void)copyIntoTiles:(id)a0;
- (void)renderTilesIntoTiles:(id)a0;
- (void)drawTexture:(id)a0;
- (void)drawStrokesAfterClear:(id)a0 clippedToStrokeSpaceRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 completion:(id /* block */)a2;
- (void)renderWithTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 inputScale:(double)a1 at:(double)a2;
- (void)generateSmartFillMaskForStroke:(id)a0 maskPaths:(const struct vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> >, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > > > { struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x0; struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x1; struct __compressed_pair<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > > > { struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x0; } x2; } *)a1 completionBlock:(id /* block */)a2;

@end
