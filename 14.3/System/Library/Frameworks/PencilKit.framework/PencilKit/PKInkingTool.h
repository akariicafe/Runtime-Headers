@class NSString, UIColor, PKInk;

@interface PKInkingTool : PKTool

@property (readonly, nonatomic) NSString *inkType;
@property (readonly, nonatomic) UIColor *color;
@property (readonly, nonatomic) double width;
@property (readonly, nonatomic) PKInk *ink;

+ (id)convertColor:(id)a0 fromUserInterfaceStyle:(long long)a1 to:(long long)a2;
+ (double)_weightForWidth:(double)a0 type:(id)a1;
+ (double)defaultWidthForInkType:(id)a0;
+ (double)_widthForWeight:(double)a0 type:(id)a1;
+ (struct unordered_map<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear> > > { struct __hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::hash<std::__1::basic_string<char> >, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::equal_to<std::__1::basic_string<char> >, true> > { float x0; } x3; } x0; } *)_weightToWidthMap;
+ (BOOL)_isUsingSystemColorPicker;
+ (struct { struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; } x0; BOOL x1; long long x2; double x3; double x4; double x5; double x6; id x7; unsigned long long x8; })_contextForStroke:(id)a0 weight:(double)a1 type:(id)a2;
+ (double)_calculateWidthForWeight:(double)a0 type:(id)a1;
+ (void)_computeWeightToWidthMapFor:(id)a0 in:(struct unordered_map<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear, std::__1::hash<std::__1::basic_string<char> >, std::__1::equal_to<std::__1::basic_string<char> >, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear> > > { struct __hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::hash<std::__1::basic_string<char> >, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::equal_to<std::__1::basic_string<char> >, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::hash<std::__1::basic_string<char> >, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, PKFunctionPiecewiseSimpleLinear>, std::__1::equal_to<std::__1::basic_string<char> >, true> > { float x0; } x3; } x0; } *)a1;
+ (double)minimumWidthForInkType:(id)a0;
+ (double)maximumWidthForInkType:(id)a0;
+ (double)_calculateEdgeWidthForWeight:(double)a0 type:(id)a1;

- (id)initWithInkType:(id)a0 color:(id)a1 width:(double)a2;
- (id)initWithInkType:(id)a0 color:(id)a1;
- (id)initWithInk:(id)a0 width:(double)a1;

@end
