@class NSObject;
@protocol OS_dispatch_queue;

@interface MTLLoader : NSObject {
    struct LoaderGlobalState { id x0; id x1; struct unordered_map<FileIdentifier, MTLLoadedFile *, FileIdentifier::Hash, std::__1::equal_to<FileIdentifier>, std::__1::allocator<std::__1::pair<const FileIdentifier, MTLLoadedFile *> > > { struct __hash_table<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, std::__1::__unordered_map_hasher<FileIdentifier, std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, FileIdentifier::Hash, true>, std::__1::__unordered_map_equal<FileIdentifier, std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, std::__1::equal_to<FileIdentifier>, true>, std::__1::allocator<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<FileIdentifier, std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, FileIdentifier::Hash, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<FileIdentifier, std::__1::__hash_value_type<FileIdentifier, MTLLoadedFile *>, std::__1::equal_to<FileIdentifier>, true> > { float x0; } x3; } x0; } x2; } *_global;
    NSObject<OS_dispatch_queue> *_claimQueue;
    struct unordered_map<MTLLoadedFile *, id, std::__1::hash<MTLLoadedFile *>, std::__1::equal_to<MTLLoadedFile *>, std::__1::allocator<std::__1::pair<MTLLoadedFile *const, id> > > { struct __hash_table<std::__1::__hash_value_type<MTLLoadedFile *, id>, std::__1::__unordered_map_hasher<MTLLoadedFile *, std::__1::__hash_value_type<MTLLoadedFile *, id>, std::__1::hash<MTLLoadedFile *>, true>, std::__1::__unordered_map_equal<MTLLoadedFile *, std::__1::__hash_value_type<MTLLoadedFile *, id>, std::__1::equal_to<MTLLoadedFile *>, true>, std::__1::allocator<std::__1::__hash_value_type<MTLLoadedFile *, id> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> **__value_; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> *> > { unsigned long long __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<MTLLoadedFile *, id>, void *> *> *__next_; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<MTLLoadedFile *, std::__1::__hash_value_type<MTLLoadedFile *, id>, std::__1::hash<MTLLoadedFile *>, true> > { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::__1::__unordered_map_equal<MTLLoadedFile *, std::__1::__hash_value_type<MTLLoadedFile *, id>, std::__1::equal_to<MTLLoadedFile *>, true> > { float __value_; } __p3_; } __table_; } _claims;
}

+ (BOOL)serializePaddingForOffset:(unsigned long long)a0 writer:(id /* block */)a1;
+ (BOOL)serializeUniversalBinaryHeaderWithSlice:(const struct MTLLoaderSliceIdentifier { int x0; int x1; } *)a0 offset:(const unsigned long long *)a1 length:(const unsigned long long *)a2 count:(unsigned int)a3 writer:(id /* block */)a4;
+ (BOOL)deserializeMachOWrapperWithType:(long long)a0 payloadHandler:(id /* block */)a1 reader:(id /* block */)a2;
+ (BOOL)serializeMachOContainerWithSlice:(struct MTLLoaderSliceIdentifier { int x0; int x1; })a0 payload:(const struct MTLLoaderMachOPayload { id x0; struct { unsigned char x0[32]; } x1; BOOL x2; unsigned long long x3; id x4; id x5; id x6; id x7; id x8; } *)a1 count:(unsigned int)a2 writer:(id /* block */)a3;
+ (BOOL)deserializeMachOContainerWithHandler:(id /* block */)a0 reader:(id /* block */)a1;
+ (struct MTLLoaderSliceIdentifier { int x0; int x1; })sliceIDForDescriptors;
+ (BOOL)deserializeUniversalBinaryHeaderWithHandler:(id /* block */)a0 reader:(id /* block */)a1 bytes:(unsigned long long)a2;
+ (BOOL)serializeMachOWrapperWithType:(long long)a0 slice:(struct MTLLoaderSliceIdentifier { int x0; int x1; })a1 payload:(const struct MTLLoaderMachOPayload { id x0; struct { unsigned char x0[32]; } x1; BOOL x2; unsigned long long x3; id x4; id x5; id x6; id x7; id x8; } *)a2 writer:(id /* block */)a3;
+ (id)canonicalURL:(id)a0;
+ (struct MTLLoaderSliceIdentifier { int x0; int x1; })sliceIDForAIR:(const struct MTLLibraryData { void /* function */ **x0; struct { unsigned char x0[32]; } x1; _Atomic int x2; id x3; id x4; } *)a0;
+ (struct MTLLoaderSliceIdentifier { int x0; int x1; })sliceIDForDevice:(id)a0 andDriverVersion:(unsigned long long *)a1;

- (id)init;
- (void).cxx_destruct;
- (oneway void)dealloc;
- (void)executeBlockForLoadedFile:(id)a0 withAssociatedObject:(id)a1 block:(id /* block */)a2;
- (void)disassociateLoadedFile:(id)a0 withObject:(id)a1;
- (id)associateLoadedFile:(id)a0 withObject:(id)a1;
- (id)loadFileWithURL:(id)a0 error:(id *)a1;
- (id).cxx_construct;
- (id)loadLibrariesWithDevice:(id)a0 computeDescriptor:(id)a1 error:(id *)a2;
- (void)releaseLoadedFile:(id)a0;

@end
