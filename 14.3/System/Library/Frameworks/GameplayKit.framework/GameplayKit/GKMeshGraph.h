@class NSArray, NSMutableArray;

@interface GKMeshGraph : GKGraph {
    NSMutableArray *_sourceObstacles;
    struct GKCMeshGraph { void /* function */ **x0; struct vector<GKCGraphNode *, std::__1::allocator<GKCGraphNode *> > { struct GKCGraphNode **x0; struct GKCGraphNode **x1; struct __compressed_pair<GKCGraphNode **, std::__1::allocator<GKCGraphNode *> > { struct GKCGraphNode **x0; } x2; } x1; id x2; struct Clipper { void /* function */ **x0; struct vector<ClipperLib::OutRec *, std::__1::allocator<ClipperLib::OutRec *> > { struct OutRec **x0; struct OutRec **x1; struct __compressed_pair<ClipperLib::OutRec **, std::__1::allocator<ClipperLib::OutRec *> > { struct OutRec **x0; } x2; } x1; struct vector<ClipperLib::Join *, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; struct Join **x1; struct __compressed_pair<ClipperLib::Join **, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; } x2; } x2; struct vector<ClipperLib::Join *, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; struct Join **x1; struct __compressed_pair<ClipperLib::Join **, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; } x2; } x3; struct vector<ClipperLib::IntersectNode *, std::__1::allocator<ClipperLib::IntersectNode *> > { struct IntersectNode **x0; struct IntersectNode **x1; struct __compressed_pair<ClipperLib::IntersectNode **, std::__1::allocator<ClipperLib::IntersectNode *> > { struct IntersectNode **x0; } x2; } x4; int x5; struct priority_queue<long long, std::__1::vector<long long, std::__1::allocator<long long> >, std::__1::less<long long> > { struct vector<long long, std::__1::allocator<long long> > { long long *x0; long long *x1; struct __compressed_pair<long long *, std::__1::allocator<long long> > { long long *x0; } x2; } x0; struct less<long long> { } x1; } x6; struct TEdge *x7; struct TEdge *x8; BOOL x9; int x10; int x11; BOOL x12; BOOL x13; BOOL x14; void /* function */ **x15; struct __wrap_iter<ClipperLib::LocalMinimum *> { struct LocalMinimum *x0; } x16; struct vector<ClipperLib::LocalMinimum, std::__1::allocator<ClipperLib::LocalMinimum> > { struct LocalMinimum *x0; struct LocalMinimum *x1; struct __compressed_pair<ClipperLib::LocalMinimum *, std::__1::allocator<ClipperLib::LocalMinimum> > { struct LocalMinimum *x0; } x2; } x17; BOOL x18; struct vector<ClipperLib::TEdge *, std::__1::allocator<ClipperLib::TEdge *> > { struct TEdge **x0; struct TEdge **x1; struct __compressed_pair<ClipperLib::TEdge **, std::__1::allocator<ClipperLib::TEdge *> > { struct TEdge **x0; } x2; } x19; BOOL x20; BOOL x21; } x3; struct vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> >, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > > > { struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x0; struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x1; struct __compressed_pair<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > > > { struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x0; } x2; } x4; struct vector<GKCPolygonObstacle *, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; struct GKCPolygonObstacle **x1; struct __compressed_pair<GKCPolygonObstacle **, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; } x2; } x5; struct CDT *x6; struct map<p2t::Triangle *, GKTriangleGraphNodes, std::__1::less<p2t::Triangle *>, std::__1::allocator<std::__1::pair<p2t::Triangle *const, GKTriangleGraphNodes> > > { struct __tree<std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, std::__1::__map_value_compare<p2t::Triangle *, std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, std::__1::less<p2t::Triangle *>, true>, std::__1::allocator<std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<p2t::Triangle *, std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, std::__1::less<p2t::Triangle *>, true> > { unsigned long long x0; } x2; } x0; } x7; struct vector<GKCPolygonObstacle *, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; struct GKCPolygonObstacle **x1; struct __compressed_pair<GKCPolygonObstacle **, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; } x2; } x8; struct vector<GKCPolygonObstacle *, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; struct GKCPolygonObstacle **x1; struct __compressed_pair<GKCPolygonObstacle **, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; } x2; } x9; struct vector<GKPolygonObstacle *, std::__1::allocator<GKPolygonObstacle *> > { id *x0; id *x1; struct __compressed_pair<GKPolygonObstacle *__strong *, std::__1::allocator<GKPolygonObstacle *> > { id *x0; } x2; } x10; struct map<GKCPolygonObstacle *, GKCPolygonObstacle *, std::__1::less<GKCPolygonObstacle *>, std::__1::allocator<std::__1::pair<GKCPolygonObstacle *const, GKCPolygonObstacle *> > > { struct __tree<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true>, std::__1::allocator<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true> > { unsigned long long x0; } x2; } x0; } x11; struct map<GKCPolygonObstacle *, GKCPolygonObstacle *, std::__1::less<GKCPolygonObstacle *>, std::__1::allocator<std::__1::pair<GKCPolygonObstacle *const, GKCPolygonObstacle *> > > { struct __tree<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true>, std::__1::allocator<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true> > { unsigned long long x0; } x2; } x0; } x12; struct unordered_map<p2t::Point *, GKCGraphNode2D *, std::__1::hash<p2t::Point *>, std::__1::equal_to<p2t::Point *>, std::__1::allocator<std::__1::pair<p2t::Point *const, GKCGraphNode2D *> > > { struct __hash_table<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::hash<p2t::Point *>, true>, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Point *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::hash<p2t::Point *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Point *>, true> > { float x0; } x3; } x0; } x13; struct unordered_map<p2t::Triangle *, GKCGraphNode2D *, std::__1::hash<p2t::Triangle *>, std::__1::equal_to<p2t::Triangle *>, std::__1::allocator<std::__1::pair<p2t::Triangle *const, GKCGraphNode2D *> > > { struct __hash_table<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::__unordered_map_hasher<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::hash<p2t::Triangle *>, true>, std::__1::__unordered_map_equal<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Triangle *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::hash<p2t::Triangle *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Triangle *>, true> > { float x0; } x3; } x0; } x14; struct unordered_map<p2t::Edge *, GKCGraphNode2D *, std::__1::hash<p2t::Edge *>, std::__1::equal_to<p2t::Edge *>, std::__1::allocator<std::__1::pair<p2t::Edge *const, GKCGraphNode2D *> > > { struct __hash_table<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::__unordered_map_hasher<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::hash<p2t::Edge *>, true>, std::__1::__unordered_map_equal<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Edge *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::hash<p2t::Edge *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Edge *>, true> > { float x0; } x3; } x0; } x15; struct unordered_map<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> >, std::__1::hash<p2t::Point *>, std::__1::equal_to<p2t::Point *>, std::__1::allocator<std::__1::pair<p2t::Point *const, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > > > > { struct __hash_table<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::hash<p2t::Point *>, true>, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::equal_to<p2t::Point *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > > > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::hash<p2t::Point *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::equal_to<p2t::Point *>, true> > { float x0; } x3; } x0; } x16; BOOL x17; BOOL x18; BOOL x19; id x20; float x21; } *_cMeshGraph;
    Class _nodeClass;
}

@property (readonly, nonatomic) NSArray *obstacles;
@property (readonly, nonatomic) float bufferRadius;
@property (nonatomic) unsigned long long triangulationMode;
@property (readonly, nonatomic) unsigned long long triangleCount;

+ (BOOL)supportsSecureCoding;
+ (id)graphWithBufferRadius:(id)a0 minCoordinate:(SEL)a1 maxCoordinate:(float)a2 nodeClass:(Class)a3;
+ (id)graphWithBufferRadius:(id)a0 minCoordinate:(SEL)a1 maxCoordinate:(float)a2;

- (void).cxx_destruct;
- (Class)nodeClass;
- (id)initWithCoder:(id)a0;
- (void)encodeWithCoder:(id)a0;
- (id)initWithBufferRadius:(id)a0 minCoordinate:(SEL)a1 maxCoordinate:(float)a2 nodeClass:(Class)a3;
- (struct GKCGraph { void /* function */ **x0; struct vector<GKCGraphNode *, std::__1::allocator<GKCGraphNode *> > { struct GKCGraphNode **x0; struct GKCGraphNode **x1; struct __compressed_pair<GKCGraphNode **, std::__1::allocator<GKCGraphNode *> > { struct GKCGraphNode **x0; } x2; } x1; id x2; } *)makeCGraph;
- (struct GKCMeshGraph { void /* function */ **x0; struct vector<GKCGraphNode *, std::__1::allocator<GKCGraphNode *> > { struct GKCGraphNode **x0; struct GKCGraphNode **x1; struct __compressed_pair<GKCGraphNode **, std::__1::allocator<GKCGraphNode *> > { struct GKCGraphNode **x0; } x2; } x1; id x2; struct Clipper { void /* function */ **x0; struct vector<ClipperLib::OutRec *, std::__1::allocator<ClipperLib::OutRec *> > { struct OutRec **x0; struct OutRec **x1; struct __compressed_pair<ClipperLib::OutRec **, std::__1::allocator<ClipperLib::OutRec *> > { struct OutRec **x0; } x2; } x1; struct vector<ClipperLib::Join *, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; struct Join **x1; struct __compressed_pair<ClipperLib::Join **, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; } x2; } x2; struct vector<ClipperLib::Join *, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; struct Join **x1; struct __compressed_pair<ClipperLib::Join **, std::__1::allocator<ClipperLib::Join *> > { struct Join **x0; } x2; } x3; struct vector<ClipperLib::IntersectNode *, std::__1::allocator<ClipperLib::IntersectNode *> > { struct IntersectNode **x0; struct IntersectNode **x1; struct __compressed_pair<ClipperLib::IntersectNode **, std::__1::allocator<ClipperLib::IntersectNode *> > { struct IntersectNode **x0; } x2; } x4; int x5; struct priority_queue<long long, std::__1::vector<long long, std::__1::allocator<long long> >, std::__1::less<long long> > { struct vector<long long, std::__1::allocator<long long> > { long long *x0; long long *x1; struct __compressed_pair<long long *, std::__1::allocator<long long> > { long long *x0; } x2; } x0; struct less<long long> { } x1; } x6; struct TEdge *x7; struct TEdge *x8; BOOL x9; int x10; int x11; BOOL x12; BOOL x13; BOOL x14; void /* function */ **x15; struct __wrap_iter<ClipperLib::LocalMinimum *> { struct LocalMinimum *x0; } x16; struct vector<ClipperLib::LocalMinimum, std::__1::allocator<ClipperLib::LocalMinimum> > { struct LocalMinimum *x0; struct LocalMinimum *x1; struct __compressed_pair<ClipperLib::LocalMinimum *, std::__1::allocator<ClipperLib::LocalMinimum> > { struct LocalMinimum *x0; } x2; } x17; BOOL x18; struct vector<ClipperLib::TEdge *, std::__1::allocator<ClipperLib::TEdge *> > { struct TEdge **x0; struct TEdge **x1; struct __compressed_pair<ClipperLib::TEdge **, std::__1::allocator<ClipperLib::TEdge *> > { struct TEdge **x0; } x2; } x19; BOOL x20; BOOL x21; } x3; struct vector<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> >, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > > > { struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x0; struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x1; struct __compressed_pair<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *, std::__1::allocator<std::__1::vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > > > { struct vector<ClipperLib::IntPoint, std::__1::allocator<ClipperLib::IntPoint> > *x0; } x2; } x4; struct vector<GKCPolygonObstacle *, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; struct GKCPolygonObstacle **x1; struct __compressed_pair<GKCPolygonObstacle **, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; } x2; } x5; struct CDT *x6; struct map<p2t::Triangle *, GKTriangleGraphNodes, std::__1::less<p2t::Triangle *>, std::__1::allocator<std::__1::pair<p2t::Triangle *const, GKTriangleGraphNodes> > > { struct __tree<std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, std::__1::__map_value_compare<p2t::Triangle *, std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, std::__1::less<p2t::Triangle *>, true>, std::__1::allocator<std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<p2t::Triangle *, std::__1::__value_type<p2t::Triangle *, GKTriangleGraphNodes>, std::__1::less<p2t::Triangle *>, true> > { unsigned long long x0; } x2; } x0; } x7; struct vector<GKCPolygonObstacle *, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; struct GKCPolygonObstacle **x1; struct __compressed_pair<GKCPolygonObstacle **, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; } x2; } x8; struct vector<GKCPolygonObstacle *, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; struct GKCPolygonObstacle **x1; struct __compressed_pair<GKCPolygonObstacle **, std::__1::allocator<GKCPolygonObstacle *> > { struct GKCPolygonObstacle **x0; } x2; } x9; struct vector<GKPolygonObstacle *, std::__1::allocator<GKPolygonObstacle *> > { id *x0; id *x1; struct __compressed_pair<GKPolygonObstacle *__strong *, std::__1::allocator<GKPolygonObstacle *> > { id *x0; } x2; } x10; struct map<GKCPolygonObstacle *, GKCPolygonObstacle *, std::__1::less<GKCPolygonObstacle *>, std::__1::allocator<std::__1::pair<GKCPolygonObstacle *const, GKCPolygonObstacle *> > > { struct __tree<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true>, std::__1::allocator<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true> > { unsigned long long x0; } x2; } x0; } x11; struct map<GKCPolygonObstacle *, GKCPolygonObstacle *, std::__1::less<GKCPolygonObstacle *>, std::__1::allocator<std::__1::pair<GKCPolygonObstacle *const, GKCPolygonObstacle *> > > { struct __tree<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true>, std::__1::allocator<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<GKCPolygonObstacle *, std::__1::__value_type<GKCPolygonObstacle *, GKCPolygonObstacle *>, std::__1::less<GKCPolygonObstacle *>, true> > { unsigned long long x0; } x2; } x0; } x12; struct unordered_map<p2t::Point *, GKCGraphNode2D *, std::__1::hash<p2t::Point *>, std::__1::equal_to<p2t::Point *>, std::__1::allocator<std::__1::pair<p2t::Point *const, GKCGraphNode2D *> > > { struct __hash_table<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::hash<p2t::Point *>, true>, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Point *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::hash<p2t::Point *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Point *>, true> > { float x0; } x3; } x0; } x13; struct unordered_map<p2t::Triangle *, GKCGraphNode2D *, std::__1::hash<p2t::Triangle *>, std::__1::equal_to<p2t::Triangle *>, std::__1::allocator<std::__1::pair<p2t::Triangle *const, GKCGraphNode2D *> > > { struct __hash_table<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::__unordered_map_hasher<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::hash<p2t::Triangle *>, true>, std::__1::__unordered_map_equal<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Triangle *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::hash<p2t::Triangle *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Triangle *, std::__1::__hash_value_type<p2t::Triangle *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Triangle *>, true> > { float x0; } x3; } x0; } x14; struct unordered_map<p2t::Edge *, GKCGraphNode2D *, std::__1::hash<p2t::Edge *>, std::__1::equal_to<p2t::Edge *>, std::__1::allocator<std::__1::pair<p2t::Edge *const, GKCGraphNode2D *> > > { struct __hash_table<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::__unordered_map_hasher<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::hash<p2t::Edge *>, true>, std::__1::__unordered_map_equal<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Edge *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::hash<p2t::Edge *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Edge *, std::__1::__hash_value_type<p2t::Edge *, GKCGraphNode2D *>, std::__1::equal_to<p2t::Edge *>, true> > { float x0; } x3; } x0; } x15; struct unordered_map<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> >, std::__1::hash<p2t::Point *>, std::__1::equal_to<p2t::Point *>, std::__1::allocator<std::__1::pair<p2t::Point *const, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > > > > { struct __hash_table<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::hash<p2t::Point *>, true>, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::equal_to<p2t::Point *>, true>, std::__1::allocator<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > > > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::hash<p2t::Point *>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<p2t::Point *, std::__1::__hash_value_type<p2t::Point *, std::__1::vector<p2t::Edge *, std::__1::allocator<p2t::Edge *> > >, std::__1::equal_to<p2t::Point *>, true> > { float x0; } x3; } x0; } x16; BOOL x17; BOOL x18; BOOL x19; id x20; float x21; } *)cMeshGraph;
- (void)setMakeNodesFromTriangleCenters:(BOOL)a0;
- (BOOL)makeNodesFromTriangleCenters;
- (void)setMakeNodesFromTriangleVertices:(BOOL)a0;
- (BOOL)makeNodesFromTriangleVertices;
- (void)setMakeNodesFromTriangleEdgeMidpoints:(BOOL)a0;
- (BOOL)makeNodesFromTriangleEdgeMidpoints;
- (id)initWithBufferRadius:(id)a0 minCoordinate:(SEL)a1 maxCoordinate:(float)a2;
- (void)addObstacles:(id)a0;
- (void)removeObstacles:(id)a0;
- (void)connectNodeUsingObstacles:(id)a0;
- (void)triangulate;
- (struct GKTriangle { void /* unknown type, empty encoding */ x0[3]; })triangleAtIndex:(unsigned long long)a0;
- (Class)classForGenericArgumentAtIndex:(unsigned long long)a0;

@end
