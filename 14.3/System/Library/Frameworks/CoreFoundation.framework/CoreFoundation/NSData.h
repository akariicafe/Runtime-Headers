@interface NSData : NSObject <NSCopying, NSMutableCopying, NSSecureCoding>

@property (class, readonly) BOOL supportsSecureCoding;

@property (readonly) unsigned long long length;
@property (readonly) const void *bytes;

+ (id)allocWithZone:(struct _NSZone { } *)a0;
+ (id)_alloc;
+ (id)dataWithBytes:(const void *)a0 length:(unsigned long long)a1;
+ (id)dataWithContentsOfURL:(id)a0 options:(unsigned long long)a1 maxLength:(unsigned long long)a2 error:(id *)a3;
+ (id)dataWithBytesNoCopy:(void *)a0 length:(unsigned long long)a1 freeWhenDone:(BOOL)a2;
+ (id)dataWithContentsOfURL:(id)a0;
+ (id)dataWithContentsOfURL:(id)a0 options:(unsigned long long)a1 error:(id *)a2;
+ (id)dataWithData:(id)a0;
+ (id)_newZeroingDataWithBytesNoCopy:(void *)a0 length:(unsigned long long)a1 deallocator:(id /* block */)a2;
+ (BOOL)_base64DecodingAlwaysSucceedsForOptions:(unsigned long long)a0;
+ (id)dataWithBytesNoCopy:(void *)a0 length:(unsigned long long)a1;
+ (id)data;
+ (id)dataWithContentsOfFile:(id)a0;
+ (id)_newZeroingDataWithBytes:(const void *)a0 length:(unsigned long long)a1;
+ (id)dataWithContentsOfFile:(id)a0 options:(unsigned long long)a1 error:(id *)a2;
+ (id)dataWithContentsOfMappedFile:(id)a0;
+ (id)CKDataWithHexString:(id)a0;
+ (id)CKDataWithHexString:(id)a0 stringIsUppercase:(BOOL)a1;

- (const void *)bytes;
- (id)initWithBytes:(void *)a0 length:(unsigned long long)a1 copy:(BOOL)a2 deallocator:(id /* block */)a3;
- (BOOL)isNSData__;
- (unsigned long long)length;
- (BOOL)_decodeBase64EncodedCharacterBuffer:(const char *)a0 length:(unsigned long long)a1 options:(unsigned long long)a2 buffer:(char *)a3 bufferLength:(unsigned long long)a4 state:(struct { BOOL x0; BOOL x1; unsigned long long x2; unsigned long long x3; unsigned long long x4; unsigned int x5; } *)a5;
- (BOOL)_providesConcreteBacking;
- (id)initWithContentsOfURL:(id)a0;
- (id)initWithBytes:(const void *)a0 length:(unsigned long long)a1;
- (id)replacementObjectForCoder:(id)a0;
- (BOOL)_isDispatchData;
- (id)initWithContentsOfFile:(id)a0 options:(unsigned long long)a1 maxLength:(unsigned long long)a2 error:(id *)a3;
- (unsigned long long)_cfTypeID;
- (id)initWithContentsOfFile:(id)a0;
- (id)initWithContentsOfURL:(id)a0 options:(unsigned long long)a1 maxLength:(unsigned long long)a2 error:(id *)a3;
- (id)_dataWithCompressionOperation:(int)a0 algorithm:(long long)a1;
- (id)_web_guessedMIMETypeForExtension:(id)a0;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (id)base64EncodedStringWithOptions:(unsigned long long)a0;
- (BOOL)isEqualToData:(id)a0;
- (BOOL)_allowsDirectEncoding;
- (id)initWithContentsOfMappedFile:(id)a0 error:(id *)a1;
- (id)_createDispatchData;
- (id)compressedDataUsingAlgorithm:(long long)a0 error:(id *)a1;
- (id)initWithData:(id)a0;
- (BOOL)_copyWillRetain;
- (id)_initWithBase64EncodedObject:(id)a0 options:(unsigned long long)a1;
- (id)decompressedDataUsingAlgorithm:(long long)a0 error:(id *)a1;
- (id)_base64EncodingAsString:(BOOL)a0 withOptions:(unsigned long long)a1;
- (void)getBytes:(void *)a0 length:(unsigned long long)a1;
- (id)_web_parseRFC822HeaderFields;
- (id)_replaceCString:(const char *)a0 withCString:(const char *)a1;
- (id)base64Encoding;
- (BOOL)writeToFile:(id)a0 atomically:(BOOL)a1 error:(id *)a2;
- (id)initWithContentsOfFile:(id)a0 error:(id *)a1;
- (id)base64EncodedDataWithOptions:(unsigned long long)a0;
- (unsigned long long)hash;
- (id)_web_guessedMIMEType;
- (id)initWithBytesNoCopy:(void *)a0 length:(unsigned long long)a1 freeWhenDone:(BOOL)a2;
- (id)initWithCoder:(id)a0;
- (id)_asciiDescription;
- (id)mutableCopyWithZone:(struct _NSZone { } *)a0;
- (id)_web_guessedMIMETypeForXML;
- (id)initWithContentsOfURL:(id)a0 options:(unsigned long long)a1 error:(id *)a2;
- (id)initWithBase64Encoding:(id)a0;
- (id)description;
- (void)getBytes:(void *)a0 range:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a1;
- (BOOL)writeToFile:(id)a0 options:(unsigned long long)a1 error:(id *)a2;
- (BOOL)isEqual:(id)a0;
- (id)initWithBase64EncodedString:(id)a0 options:(unsigned long long)a1;
- (void)enumerateByteRangesUsingBlock:(id /* block */)a0;
- (BOOL)writeToURL:(id)a0 atomically:(BOOL)a1;
- (id)subdataWithRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (BOOL)_canReplaceWithDispatchDataForXPCCoder;
- (id)initWithBase64EncodedData:(id)a0 options:(unsigned long long)a1;
- (id)initWithContentsOfFile:(id)a0 options:(unsigned long long)a1 error:(id *)a2;
- (id)debugDescription;
- (id)initWithBytes:(void *)a0 length:(unsigned long long)a1 copy:(BOOL)a2 freeWhenDone:(BOOL)a3 bytesAreVM:(BOOL)a4;
- (BOOL)_isCompact;
- (id)initWithContentsOfMappedFile:(id)a0;
- (Class)classForCoder;
- (id)initWithBytesNoCopy:(void *)a0 length:(unsigned long long)a1;
- (BOOL)writeToFile:(id)a0 atomically:(BOOL)a1;
- (BOOL)writeToURL:(id)a0 options:(unsigned long long)a1 error:(id *)a2;
- (id)replacementObjectForPortCoder:(id)a0;
- (void)encodeWithCoder:(id)a0;
- (id)initWithBytesNoCopy:(void *)a0 length:(unsigned long long)a1 deallocator:(id /* block */)a2;
- (struct _NSRange { unsigned long long x0; unsigned long long x1; })rangeOfData:(id)a0 options:(unsigned long long)a1 range:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a2;
- (void)getBytes:(void *)a0;
- (BOOL)_isSafeResumeDataForBackgroundDownload;
- (id)_requestFromResumeData;
- (id)CKUppercaseHexStringWithoutSpaces;
- (id)CKLowercaseHexStringWithoutSpaces;
- (id)CKHexString;

@end
