@class NSMutableDictionary, HDContentProtectionManager, HDProfile, NSDate, NSDictionary, NSObject, HDAssertionManager, HDDatabaseJournal, NSMutableArray, NSConditionLock, NSString, NSHashTable, NSMutableSet, NSOperationQueue, HDHFDataStore, HKObserverSet, NSLock;
@protocol OS_dispatch_queue, OS_dispatch_group, OS_dispatch_source;

@interface HDDatabase : NSObject <HDAssertionObserver, HDContentProtectionObserver, HDDiagnosticObject, HDSQLiteDatabaseDelegate, HDSQLiteDatabasePoolDelegate, HDSQLiteDatabaseProvider, HDDatabaseJournalDelegate, HDHFDataStoreDelegate, HDDatabaseMigrationTransactionDelegate, HDHealthDatabase> {
    _Atomic BOOL _invalidated;
    NSObject<OS_dispatch_queue> *_serialAsynchronousQueue;
    HDHFDataStore *_hfDataStore;
    NSLock *_writeLock;
    NSObject<OS_dispatch_queue> *_protectedDataQueue;
    HKObserverSet *_protectedDataObservers;
    long long _protectedDataState;
    long long _observedContentProtectionState;
    BOOL _isObservingContentProtection;
    NSMutableArray *_firstUnlockBlocks;
    BOOL _shouldNotifyFirstUnlockObservers;
    NSDate *_protectedDataFlushDeadlineDate;
    NSObject<OS_dispatch_source> *_protectedDataFlushDeadlineTimer;
    BOOL _hasFlushedProtectedData;
    _Atomic BOOL _hasPendingSecondaryJournalMerge;
    NSMutableDictionary *_databaseJournalMergeObserverSetByType;
}

@property (readonly, copy, nonatomic) NSString *profileDirectoryPath;
@property (readonly, copy, nonatomic) NSString *threadLocalTransactionKey;
@property (readonly, copy, nonatomic) NSString *threadLocalTransactionContextKey;
@property (readonly, copy, nonatomic) NSString *threadLocalIgnoreTransactionContextKey;
@property (readonly) BOOL invalidated;
@property (retain, nonatomic) HDAssertionManager *assertionManager;
@property (retain, nonatomic) NSLock *schemaMigrationLock;
@property (retain, nonatomic) NSConditionLock *activeDatabasesLock;
@property (retain, nonatomic) NSMutableSet *activeDatabases;
@property (retain, nonatomic) NSHashTable *migratedDatabases;
@property (retain, nonatomic) NSOperationQueue *asynchronousOperationQueue;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *journalQueue;
@property (retain, nonatomic) NSObject<OS_dispatch_group> *journalGroup;
@property (nonatomic) unsigned long long pendingJournalMerges;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *secondaryJournalMergeQueue;
@property (retain, nonatomic) NSMutableDictionary *extendedTransactions;
@property (retain, nonatomic) NSDictionary *databasePoolForType;
@property (readonly, nonatomic) HDContentProtectionManager *contentProtectionManager;
@property (nonatomic) double offsetTimeInterval;
@property (nonatomic) double protectedDataFlushInterval;
@property (nonatomic) BOOL didRunPostMigrationUpdates;
@property (nonatomic) long long corruptedMigrationAttemptsCount;
@property (copy, nonatomic) id /* block */ unitTest_didWaitForJournalMergeHandler;
@property (readonly, nonatomic) HDDatabaseJournal *journal;
@property (readonly, nonatomic) HDDatabaseJournal *cloudSyncJournal;
@property (weak, nonatomic) HDProfile *profile;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, nonatomic, getter=isDataProtectedByFirstUnlockAvailable) BOOL dataProtectedByFirstUnlockAvailable;
@property (readonly, nonatomic, getter=isProtectedDataAvailable) BOOL protectedDataAvailable;

+ (BOOL)unitTest_prepareUnprotectedDatabase:(id)a0 protectedDatabase:(id)a1 error:(id *)a2;
+ (long long)unitTest_createOrMigrateDatabaseAtDirectoryURL:(id)a0 schemaProviders:(id)a1 behavior:(id)a2 error:(id *)a3;
+ (id)createDatabaseConnectionWithURL:(id)a0;
+ (id)allCurrentAndFutureEntityClasses;
+ (id)allEntityClassesWithBehavior:(id)a0;

- (void)invalidateAndWait;
- (void)assertionManager:(id)a0 assertionInvalidated:(id)a1;
- (void)contentProtectionStateChanged:(long long)a0 previousState:(long long)a1;
- (id)initWithProfile:(id)a0;
- (BOOL)performTransactionWithContext:(id)a0 error:(id *)a1 block:(id /* block */)a2 inaccessibilityHandler:(id /* block */)a3;
- (BOOL)_allowProtectedDataAccessWhileLockedWithTransaction:(id)a0;
- (id)_currentDatabaseJournal;
- (void)databasePool:(id)a0 didFlushDatabases:(id)a1;
- (void)removeDatabaseJournalMergeObserver:(id)a0 journalType:(long long)a1;
- (id)_URLForWALForDatabaseAtURL:(id)a0;
- (void)databaseJournalMergeDidComplete:(id)a0;
- (id)_createDatabaseConnectionWithType:(long long)a0;
- (BOOL)migrateDataForHFDataStore:(id)a0 from:(const struct DataStore { struct BlockAccessFile { struct TransactionalFile { struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x0; struct WriteAheadLog { struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x0; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x1; struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x2; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x3; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x4; unsigned long long x5; unsigned long long x6; long long x7; BOOL x8; struct vector<std::__1::shared_ptr<health::WriteAheadLog::Transaction>, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; struct shared_ptr<health::WriteAheadLog::Transaction> *x1; struct __compressed_pair<std::__1::shared_ptr<health::WriteAheadLog::Transaction> *, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; } x2; } x9; struct unordered_multiset<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct __hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::hash<unsigned long long> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::equal_to<unsigned long long> > { float x0; } x3; } x0; } x10; struct map<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> >, std::__1::less<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true> > { unsigned long long x0; } x2; } x0; } x11; } x1; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x2; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x3; BOOL x4; struct FileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; unsigned long long x4; unsigned long long x5; } x5; unsigned long long x6; unsigned long long x7; int x8; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x9; struct TransactionalCache<unsigned long long, health::FilePage> { unsigned long long x0; unsigned long long x1; struct unordered_map<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct __hash_table<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true> > { float x0; } x3; } x0; } x2; struct CacheEntry *x3; struct CacheEntry *x4; struct function<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct __value_func<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct type { unsigned char x0[24]; } x0; struct __base<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> *x1; } x0; } x5; } x10; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x11; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x12; struct map<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x13; struct queue<std::__1::__thread_id, std::__1::deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > > { struct deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > { struct __split_buffer<std::__1::__thread_id *, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; struct __thread_id **x1; struct __thread_id **x2; struct __compressed_pair<std::__1::__thread_id **, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; } x3; } x0; unsigned long long x1; struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__thread_id> > { unsigned long long x0; } x2; } x0; } x14; struct map<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x15; } x0; struct BlockAccessFileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x4; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x5; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x6; } x1; } x0; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x1; } *)a1 to:(struct DataStore { struct BlockAccessFile { struct TransactionalFile { struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x0; struct WriteAheadLog { struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x0; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x1; struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x2; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x3; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x4; unsigned long long x5; unsigned long long x6; long long x7; BOOL x8; struct vector<std::__1::shared_ptr<health::WriteAheadLog::Transaction>, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; struct shared_ptr<health::WriteAheadLog::Transaction> *x1; struct __compressed_pair<std::__1::shared_ptr<health::WriteAheadLog::Transaction> *, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; } x2; } x9; struct unordered_multiset<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct __hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::hash<unsigned long long> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::equal_to<unsigned long long> > { float x0; } x3; } x0; } x10; struct map<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> >, std::__1::less<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true> > { unsigned long long x0; } x2; } x0; } x11; } x1; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x2; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x3; BOOL x4; struct FileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; unsigned long long x4; unsigned long long x5; } x5; unsigned long long x6; unsigned long long x7; int x8; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x9; struct TransactionalCache<unsigned long long, health::FilePage> { unsigned long long x0; unsigned long long x1; struct unordered_map<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct __hash_table<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true> > { float x0; } x3; } x0; } x2; struct CacheEntry *x3; struct CacheEntry *x4; struct function<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct __value_func<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct type { unsigned char x0[24]; } x0; struct __base<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> *x1; } x0; } x5; } x10; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x11; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x12; struct map<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x13; struct queue<std::__1::__thread_id, std::__1::deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > > { struct deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > { struct __split_buffer<std::__1::__thread_id *, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; struct __thread_id **x1; struct __thread_id **x2; struct __compressed_pair<std::__1::__thread_id **, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; } x3; } x0; unsigned long long x1; struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__thread_id> > { unsigned long long x0; } x2; } x0; } x14; struct map<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x15; } x0; struct BlockAccessFileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x4; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x5; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x6; } x1; } x0; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x1; } *)a2 recoveryAnalytics:(id)a3 error:(id *)a4;
- (BOOL)discardHighFrequencyDataStoreWithError:(id *)a0;
- (BOOL)addJournalEntries:(id)a0 error:(id *)a1;
- (void)addDatabaseJournalMergeObserver:(id)a0 journalType:(long long)a1 queue:(id)a2;
- (id)databaseURLForType:(long long)a0;
- (void).cxx_destruct;
- (id)_threadLocalTransaction;
- (long long)HFDataStore:(id)a0 integerForKey:(id)a1;
- (id)newDatabaseForDatabasePool:(id)a0 error:(id *)a1;
- (void)addProtectedDataObserver:(id)a0;
- (id)_cloudSyncJournalDirectoryPath;
- (id)activeTransactionForCurrentThreadForHFDataStore:(id)a0;
- (id)databaseSizeInBytesExcludingHFD;
- (void)obliterateWithReason:(id)a0 preserveCopy:(BOOL)a1;
- (void)_protectedDataQueue_beginObservingContentProtection;
- (void)dealloc;
- (void)HFDataStoreDidPerformRebuild:(id)a0 didDecompressArchivedHFD:(BOOL)a1 didOpenArchivedHFD:(BOOL)a2 didOpenMovedAsideHFD:(BOOL)a3 recoveryAnalytics:(id)a4 duration:(double)a5;
- (void)HFDataStore:(id)a0 setInteger:(long long)a1 forKey:(id)a2;
- (BOOL)addJournalEntry:(id)a0 error:(id *)a1;
- (void)checkInDatabase:(id)a0 type:(long long)a1;
- (BOOL)_runPostMigrationUpdatesWithDatabase:(id)a0 error:(id *)a1;
- (id)_journalDirectoryPath;
- (void)migrationTransaction:(id)a0 didEncounterDatabaseMismatchWithUnprotectedIdentifier:(id)a1 protectedIdentifier:(id)a2;
- (long long)databaseTypeForDatabasePool:(id)a0;
- (BOOL)_migrateOrCreateProtectedSchemaInDatabase:(id)a0 transaction:(id)a1 error:(id *)a2;
- (id)_journalForType:(long long)a0;
- (long long)_protectedDataState;
- (id)protectedDatabaseURL;
- (BOOL)_waitForMergesWithCurrentJournal:(id)a0 error:(id *)a1;
- (BOOL)_canAttachProtectedDatabaseForTransaction:(id)a0 error:(id *)a1;
- (void)removeProtectedDataObserver:(id)a0;
- (void)_checkInDatabase:(id)a0 type:(long long)a1 flushImmediately:(BOOL)a2;
- (void)addProtectedDataObserver:(id)a0 queue:(id)a1;
- (id)allEntityClassesWithProtectionClass:(long long)a0;
- (void)performAsynchronouslySerial:(id /* block */)a0;
- (id)highFrequencyDataStoreURL;
- (BOOL)accessHighFrequencyDataStoreWithError:(id *)a0 block:(id /* block */)a1;
- (id)diagnosticDescription;
- (void)_protectedDataQueue_flushProtectedDataIfNecessary;
- (void)performAsynchronously:(id /* block */)a0;
- (void)_protectedDataQueue_mergeJournalAsynchronously;
- (void)beginObservingContentProtection;
- (id)checkOutProtectedDatabase:(id)a0 highFrequencyDataStore:(id *)a1 error:(id *)a2;
- (id)_checkOutDatabaseForTransaction:(id)a0 databaseType:(long long)a1 error:(id *)a2;
- (BOOL)performWithJournalType:(long long)a0 error:(id *)a1 block:(id /* block */)a2;
- (id)_newDatabaseConnectionWithType:(long long)a0 error:(id *)a1;
- (void)_reportMigrationResultIfNecessaryForStatus:(long long)a0 database:(id)a1 protectedDatabase:(BOOL)a2 error:(id)a3;
- (BOOL)_protectedDataQueue_isProtectedDataFlushDeadlinePassed;
- (void)didMigrateHFDataStore:(id)a0 fromState:(long long)a1 toState:(long long)a2 success:(BOOL)a3 error:(id)a4;
- (void)finalizeExtendedTransactionForIdentifier:(id)a0;
- (id)extendedDatabaseTransactionForIdentifier:(id)a0;
- (void)unitTest_setContentProtectionStateAndWait:(long long)a0;
- (id)beginExtendedTransactionWithContext:(id)a0 transactionTimeout:(double)a1 continuationTimeout:(double)a2 error:(id *)a3;
- (void)performWhenDataProtectedByFirstUnlockIsAvailableOnQueue:(id)a0 block:(id /* block */)a1;
- (id)HFDSizeInBytes;
- (id)mainDatabaseURL;
- (id)cloneAccessibilityAssertion:(id)a0 ownerIdentifier:(id)a1 error:(id *)a2;
- (long long)_performMigrationWithUnprotectedDatabase:(id)a0 protectedDatabase:(id)a1 error:(id *)a2;
- (BOOL)_applyOffsetTimeInterval:(double)a0 database:(id)a1 error:(id *)a2;
- (void)_triggerHFDRebuildMaintenanceTask;
- (BOOL)_attachProtectedDatabaseIfNeededToDatabase:(id)a0 transaction:(id)a1 error:(id *)a2;
- (long long)_fileSizeForURL:(id)a0 error:(id *)a1;
- (void)_performWhenDataProtectedByFirstUnlockIsAvailableOnQueue:(id)a0 block:(id /* block */)a1;
- (void)_protectedDataQueue_cancelProtectedDataFlushTimer;
- (id)takeAccessibilityAssertionWithOwnerIdentifier:(id)a0 timeout:(double)a1 error:(id *)a2;
- (void)performWhenDataProtectedByFirstUnlockIsAvailable:(id /* block */)a0;
- (void)_mergeSecondaryJournals;
- (id)databaseSizeInBytesForTypeUnprotected:(BOOL)a0 WAL:(BOOL)a1;
- (BOOL)performHighPriorityTransactionsWithError:(id *)a0 block:(id /* block */)a1;
- (id)databasePoolForDatabaseType:(long long)a0;
- (BOOL)_journalQueue_performJournalMergeAndCleanup;
- (id)unitTest_currentTransaction;
- (BOOL)_isDatabaseValidWithError:(id *)a0;
- (id)_createAndVerifyDatabaseConnectionWithType:(long long)a0 error:(id *)a1;
- (id)checkOutUnprotectedDatabase:(id)a0 error:(id *)a1;
- (id)_newDataStoreForPath:(id)a0;
- (void)requestRebuildTransactionForHFDataStore:(id)a0;
- (id)takeAccessibilityAssertionWithOwnerIdentifier:(id)a0 shouldPerformTransaction:(BOOL)a1 timeout:(double)a2 error:(id *)a3;
- (unsigned long long)journalChapterCountForType:(long long)a0;
- (void)HFDataStore:(id)a0 detectedCorruptionOfType:(long long)a1 code:(int)a2 error:(id)a3 shouldPromptUser:(BOOL)a4 initialRebuildState:(long long)a5 updatedRebuildState:(long long)a6;
- (void)migrationTransaction:(id)a0 didCreateDatabasesWithIdentifier:(id)a1;
- (id)_threadLocalTransactionContext;
- (BOOL)performWithTransactionContext:(id)a0 error:(id *)a1 block:(id /* block */)a2;
- (long long)_migrateOrCreateProtectedSchemaInDatabaseIfWritable:(id)a0 error:(id *)a1;
- (id)progressForJournalMergeWithType:(long long)a0;

@end
