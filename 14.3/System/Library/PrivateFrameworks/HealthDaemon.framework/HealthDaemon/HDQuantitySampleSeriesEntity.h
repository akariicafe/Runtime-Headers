@class NSString;

@interface HDQuantitySampleSeriesEntity : HDQuantitySampleEntity <HDSeriesEntity>

@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

+ (id)indices;
+ (id)additionalPredicateForEnumeration;
+ (BOOL)migrateDataFromDataStore:(const struct DataStore { struct BlockAccessFile { struct TransactionalFile { struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x0; struct WriteAheadLog { struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x0; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x1; struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x2; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x3; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x4; unsigned long long x5; unsigned long long x6; long long x7; BOOL x8; struct vector<std::__1::shared_ptr<health::WriteAheadLog::Transaction>, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; struct shared_ptr<health::WriteAheadLog::Transaction> *x1; struct __compressed_pair<std::__1::shared_ptr<health::WriteAheadLog::Transaction> *, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; } x2; } x9; struct unordered_multiset<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct __hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::hash<unsigned long long> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::equal_to<unsigned long long> > { float x0; } x3; } x0; } x10; struct map<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> >, std::__1::less<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true> > { unsigned long long x0; } x2; } x0; } x11; } x1; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x2; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x3; BOOL x4; struct FileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; unsigned long long x4; unsigned long long x5; } x5; unsigned long long x6; unsigned long long x7; int x8; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x9; struct TransactionalCache<unsigned long long, health::FilePage> { unsigned long long x0; unsigned long long x1; struct unordered_map<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct __hash_table<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true> > { float x0; } x3; } x0; } x2; struct CacheEntry *x3; struct CacheEntry *x4; struct function<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct __value_func<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct type { unsigned char x0[24]; } x0; struct __base<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> *x1; } x0; } x5; } x10; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x11; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x12; struct map<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x13; struct queue<std::__1::__thread_id, std::__1::deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > > { struct deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > { struct __split_buffer<std::__1::__thread_id *, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; struct __thread_id **x1; struct __thread_id **x2; struct __compressed_pair<std::__1::__thread_id **, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; } x3; } x0; unsigned long long x1; struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__thread_id> > { unsigned long long x0; } x2; } x0; } x14; struct map<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x15; } x0; struct BlockAccessFileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x4; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x5; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x6; } x1; } x0; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x1; } *)a0 to:(struct DataStore { struct BlockAccessFile { struct TransactionalFile { struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x0; struct WriteAheadLog { struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x0; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x1; struct shared_ptr<health::VirtualFilesystem> { struct VirtualFilesystem *x0; struct __shared_weak_count *x1; } x2; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x3; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x4; unsigned long long x5; unsigned long long x6; long long x7; BOOL x8; struct vector<std::__1::shared_ptr<health::WriteAheadLog::Transaction>, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; struct shared_ptr<health::WriteAheadLog::Transaction> *x1; struct __compressed_pair<std::__1::shared_ptr<health::WriteAheadLog::Transaction> *, std::__1::allocator<std::__1::shared_ptr<health::WriteAheadLog::Transaction> > > { struct shared_ptr<health::WriteAheadLog::Transaction> *x0; } x2; } x9; struct unordered_multiset<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct __hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long> > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *> *>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *> > > { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> { struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::hash<unsigned long long> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::equal_to<unsigned long long> > { float x0; } x3; } x0; } x10; struct map<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> >, std::__1::less<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true>, std::__1::allocator<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > > > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<unsigned long long, std::__1::__value_type<unsigned long long, std::__1::vector<health::WriteAheadLog::PageEntry, std::__1::allocator<health::WriteAheadLog::PageEntry> > >, std::__1::less<unsigned long long>, true> > { unsigned long long x0; } x2; } x0; } x11; } x1; struct basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > { struct __compressed_pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__rep, std::__1::allocator<char> > { struct __rep { union { struct __long { char *x0; unsigned long long x1; unsigned long long x2; } x0; struct __short { char x0[23]; struct { unsigned char x0; } x1; } x1; struct __raw { unsigned long long x0[3]; } x2; } x0; } x0; } x0; } x2; struct shared_ptr<health::VirtualFile> { struct VirtualFile *x0; struct __shared_weak_count *x1; } x3; BOOL x4; struct FileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; unsigned long long x4; unsigned long long x5; } x5; unsigned long long x6; unsigned long long x7; int x8; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x9; struct TransactionalCache<unsigned long long, health::FilePage> { unsigned long long x0; unsigned long long x1; struct unordered_map<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct __hash_table<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine> > > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> **x0; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *> > { unsigned long long x0; } x0; } x1; } x0; } x0; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> > > { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> { struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, void *> *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::hash<unsigned long long>, true> > { unsigned long long x0; } x2; struct __compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, health::TransactionalCache<unsigned long long, health::FilePage>::CacheLine>, std::__1::equal_to<unsigned long long>, true> > { float x0; } x3; } x0; } x2; struct CacheEntry *x3; struct CacheEntry *x4; struct function<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct __value_func<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> { struct type { unsigned char x0[24]; } x0; struct __base<bool (unsigned long long, const unsigned long long &, const health::FilePage &)> *x1; } x0; } x5; } x10; struct mutex { struct _opaque_pthread_mutex_t { long long x0; char x1[56]; } x0; } x11; struct condition_variable { struct _opaque_pthread_cond_t { long long x0; char x1[40]; } x0; } x12; struct map<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::ReadTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x13; struct queue<std::__1::__thread_id, std::__1::deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > > { struct deque<std::__1::__thread_id, std::__1::allocator<std::__1::__thread_id> > { struct __split_buffer<std::__1::__thread_id *, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; struct __thread_id **x1; struct __thread_id **x2; struct __compressed_pair<std::__1::__thread_id **, std::__1::allocator<std::__1::__thread_id *> > { struct __thread_id **x0; } x3; } x0; unsigned long long x1; struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__thread_id> > { unsigned long long x0; } x2; } x0; } x14; struct map<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *, std::__1::less<std::__1::__thread_id>, std::__1::allocator<std::__1::pair<const std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true>, std::__1::allocator<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> *x0; struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *> *>, std::__1::allocator<std::__1::__tree_node<std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, void *> > > { struct __tree_end_node<std::__1::__tree_node_base<void *> *> { struct __tree_node_base<void *> *x0; } x0; } x1; struct __compressed_pair<unsigned long, std::__1::__map_value_compare<std::__1::__thread_id, std::__1::__value_type<std::__1::__thread_id, health::TransactionalFile::WriteTransaction *>, std::__1::less<std::__1::__thread_id>, true> > { unsigned long long x0; } x2; } x0; } x15; } x0; struct BlockAccessFileHeader { unsigned int x0; unsigned int x1; unsigned int x2; unsigned long long x3; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x4; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x5; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x6; } x1; } x0; struct BlockPointer { unsigned long long x0; unsigned long long x1; } x1; } *)a1 transaction:(id)a2 recoveryAnalytics:(id)a3 error:(id *)a4;
+ (id)entityEncoderForProfile:(id)a0 transaction:(id)a1 purpose:(long long)a2 encodingOptions:(id)a3 authorizationFilter:(id /* block */)a4;
+ (id)foreignKeys;
+ (const struct { id x0; id x1; unsigned char x2; } *)columnDefinitionsWithCount:(unsigned long long *)a0;
+ (id)_quantitySampleWithID:(id)a0 canBeUnfrozen:(BOOL)a1 profile:(id)a2 error:(id *)a3;
+ (id)insertDataObject:(id)a0 withProvenance:(id)a1 inDatabase:(id)a2 persistentID:(id)a3 error:(id *)a4;
+ (id)_updatedSampleUUIDForSeries:(id)a0 originalEntity:(id)a1 HFDKey:(long long)a2 transaction:(id)a3 profile:(id)a4 error:(id *)a5;
+ (BOOL)isConcreteEntity;
+ (id)_propertiesToLeftJoin;
+ (id)databaseTable;
+ (id)disambiguatedSQLForProperty:(id)a0;
+ (id /* block */)objectInsertionFilterForProfile:(id)a0;
+ (BOOL)_deleteHFDSeriesIfFoundForPersistentID:(id)a0 database:(id)a1 error:(id *)a2;
+ (long long)unitTesting_insertionEra;
+ (BOOL)replaceObjectID:(id)a0 replacementObjectID:(id)a1 deleteOriginalHFDData:(BOOL)a2 profile:(id)a3 transaction:(id)a4 error:(id *)a5;
+ (BOOL)replaceExistingObject:(id)a0 existingObjectID:(id)a1 replacementObject:(id)a2 replacementObjectID:(id)a3 profile:(id)a4 transaction:(id)a5 error:(id *)a6;
+ (id)quantitySampleSeriesEntitiesForAutoFreezeSQL;
+ (BOOL)primitiveRemoveDatums:(id)a0 HFDKey:(long long)a1 transaction:(id)a2 error:(id *)a3;
+ (id)removeValues:(id)a0 fromQuantitySeriesSample:(id)a1 profile:(id)a2 error:(id *)a3;
+ (void)unitTesting_updateInsertionEra;
+ (BOOL)_moveHFDKey:(long long)a0 fromEntity:(id)a1 toEntity:(id)a2 transaction:(id)a3 error:(id *)a4;
+ (id)joinClausesForProperty:(id)a0;
+ (id)privateSubEntities;
+ (BOOL)enumerateDataWithTransaction:(id)a0 HFDKey:(long long)a1 error:(id *)a2 handler:(id /* block */)a3;
+ (BOOL)enumerateDataWithIdentifier:(id)a0 profile:(id)a1 error:(id *)a2 handler:(id /* block */)a3;
+ (void)_triggerABCForNotFinalSeriesSampleInsert:(id)a0 reason:(id)a1;
+ (id)mergeDataObject:(id)a0 provenance:(id)a1 profile:(id)a2 transaction:(id)a3 error:(id *)a4 insertHandler:(id /* block */)a5;
+ (id)_statisticsWithHFDKey:(long long)a0 statisticsCalculator:(id)a1 transaction:(id)a2 error:(id *)a3;
+ (BOOL)deleteSeriesFromHFDWithKey:(long long)a0 database:(id)a1 error:(id *)a2;
+ (BOOL)_updateFrozenEntityToMatchReplacedUnfrozenEntity:(id)a0 unfrozenSeriesUUID:(id)a1 unfrozenSeriesHFDKey:(long long)a2 database:(id)a3 error:(id *)a4;
+ (BOOL)supportsObjectMerging;
+ (BOOL)unitTesting_insertValues:(id)a0 quantitySample:(id)a1 seriesVersion:(long long)a2 profile:(id)a3 error:(id *)a4;
+ (void)_setStatistics:(id)a0 discreteQuantitySeriesSample:(id)a1;
+ (BOOL)_setStatisticsForQuantitySample:(id)a0 HFDKey:(long long)a1 transaction:(id)a2 error:(id *)a3;
+ (id)hasSeriesDataForHFDKey:(id)a0 transaction:(id)a1 error:(id *)a2;
+ (BOOL)enumerateDataWithIdentifier:(id)a0 transaction:(id)a1 error:(id *)a2 handler:(id /* block */)a3;
+ (BOOL)enumerateRawDataWithTransaction:(id)a0 HFDKey:(long long)a1 error:(id *)a2 handler:(id /* block */)a3;
+ (BOOL)deleteSeriesWithID:(id)a0 deleteHFDData:(BOOL)a1 profile:(id)a2 transaction:(id)a3 error:(id *)a4;
+ (id)_statisticsProperties;
+ (BOOL)performPostJournalMergeCleanupWithTransaction:(id)a0 profile:(id)a1 error:(id *)a2;
+ (Class)entityClassForEnumeration;
+ (long long)_insertionEra;
+ (id)_insertDataObject:(id)a0 inDatabase:(id)a1 persistentID:(id)a2 error:(id *)a3;
+ (void)_setStatistics:(id)a0 cumulativeQuantitySeriesSample:(id)a1;
+ (id)_updatedSampleForSeries:(id)a0 originalEntity:(id)a1 HFDKey:(long long)a2 newCount:(long long)a3 transaction:(id)a4 profile:(id)a5 error:(id *)a6;
+ (BOOL)_replaceEntity:(id)a0 UUIDToDelete:(id)a1 newEntity:(id)a2 profile:(id)a3 error:(id *)a4;
+ (BOOL)insertValues:(id)a0 series:(id)a1 profile:(id)a2 error:(id *)a3;
+ (long long)_notFinalInserationEra;
+ (id)orderingTermForSortDescriptor:(id)a0;
+ (BOOL)primitiveInsertValues:(id)a0 seriesVersion:(long long)a1 HFDKey:(long long)a2 database:(id)a3 error:(id *)a4;
+ (id)quantitySampleSeriesEntitiesForAutoFreezeWithTransaction:(id)a0 error:(id *)a1;
+ (id)freezeSeriesWithIdentifier:(id)a0 metadata:(id)a1 endDate:(id)a2 profile:(id)a3 error:(id *)a4;
+ (BOOL)performSeriesWriteTransactionWithProfile:(id)a0 error:(id *)a1 block:(id /* block */)a2;
+ (id)_removeValues:(id)a0 fromQuantitySeriesSample:(id)a1 transaction:(id)a2 profile:(id)a3 error:(id *)a4;

- (BOOL)deleteFromDatabase:(id)a0 error:(id *)a1;
- (void)willDeleteFromDatabase:(id)a0;
- (id)HFDKeyWithDatabase:(id)a0 error:(id *)a1;
- (BOOL)insertValues:(id)a0 transaction:(id)a1 error:(id *)a2;
- (BOOL)_insertValues:(id)a0 database:(id)a1 error:(id *)a2;
- (long long)_isFrozenInDatabase:(id)a0 error:(id *)a1;
- (id)_frozenUUIDForUnfrozenQuantitySample:(id)a0 HFDKey:(long long)a1 endDate:(id)a2 transaction:(id)a3 profile:(id)a4 error:(id *)a5;
- (id)_dataOriginProvenanceWithTransaction:(id)a0 profile:(id)a1 error:(id *)a2;
- (id)_updatedSampleForQuantitySeriesSample:(id)a0 HFDKey:(long long)a1 endDate:(id)a2 transaction:(id)a3 error:(id *)a4;
- (BOOL)_getFirstTimeEndTimeCountWithTransaction:(id)a0 HFDKey:(id)a1 error:(id *)a2 handler:(id /* block */)a3;
- (BOOL)_setHFDKey:(long long)a0 database:(id)a1 error:(id *)a2;
- (BOOL)enumerateDataWithTransaction:(id)a0 error:(id *)a1 handler:(id /* block */)a2;
- (BOOL)startTimeEndTimeCountForSeriesWithTransaction:(id)a0 error:(id *)a1 handler:(id /* block */)a2;
- (BOOL)_isSeriesInDatabase:(id)a0;
- (id)_mergeCodableSeriesDataFromQuantitySampleSeries:(id)a0 profile:(id)a1 database:(id)a2 error:(id *)a3;
- (long long)_hasHFDDataWithDatabase:(id)a0 error:(id *)a1;
- (long long)_hasV1SeriesDataWithDatabase:(id)a0 error:(id *)a1;
- (BOOL)_setInsertionEra:(long long)a0 database:(id)a1 error:(id *)a2;
- (long long)_shouldMergeQuantitySampleSeries:(id)a0 codableSeries:(id)a1 database:(id)a2 error:(id *)a3;
- (id)countForSeriesWithTransaction:(id)a0 error:(id *)a1;
- (id)freezeWithEndDate:(id)a0 transaction:(id)a1 profile:(id)a2 error:(id *)a3;
- (id)hasSeriesDataWithTransaction:(id)a0 error:(id *)a1;
- (BOOL)enumerateDataInInterval:(id)a0 transaction:(id)a1 error:(id *)a2 handler:(id /* block */)a3;
- (BOOL)unitTesting_setInsertionEra:(long long)a0 profile:(id)a1 error:(id *)a2;

@end
