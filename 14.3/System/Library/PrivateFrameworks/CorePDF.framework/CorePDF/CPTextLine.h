@class NSArray, CPCharSequence;

@interface CPTextLine : CPTextObject <CPDisposable> {
    CPCharSequence *charSequence;
    struct { unsigned int x0; unsigned int x1; int x2; int x3; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x4; } *wordArray;
    unsigned int wordCount;
    struct CPInlineContainer { unsigned int x0; id x1; struct CPInlineContainer *x2; } *inlineList;
    int lineNumber;
    int columnNumber;
    double baseline;
    BOOL baseLineIsNull;
    BOOL hasBeenSplit;
    BOOL hasBeenProcessed;
    BOOL maySplit;
    BOOL hasTabs;
    NSArray *columnBreaks;
    NSArray *xsegments;
    int levels;
    float maximumLetterGap;
    float maximumWordGap;
    int tabsBefore;
    BOOL irregular;
    struct CPPDFStyle { struct CGColor *x0; struct CGColorSpace *x1; struct CGColor *x2; struct CGColorSpace *x3; double x4; double x5; unsigned char x6; unsigned char x7; int x8; double x9; id x10; double x11; struct CGPDFObject *x12; struct CGPDFObject *x13; struct CGColor *x14; struct CPPDFStyle *x15; } *uniformStyle;
    unsigned short uniformStyleFlags;
    double monospaceWidth;
    unsigned int *spacesBefore;
    BOOL disposed;
}

@property (nonatomic) unsigned int leftSpacerIndex;
@property (nonatomic) unsigned int rightSpacerIndex;
@property (nonatomic) BOOL isListItem;
@property (nonatomic) unsigned int listSpacerIndex;
@property (nonatomic) BOOL lineBreakAfter;

- (struct CGPoint { double x0; double x1; })anchor;
- (id)init;
- (long long)zOrder;
- (int)levels;
- (id)properties;
- (double)baseline;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (int)align;
- (unsigned int)wordCount;
- (struct { unsigned int x0; unsigned int x1; int x2; int x3; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x4; } *)lastWord;
- (void)dealloc;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })bounds;
- (id)attributes;
- (BOOL)hasBeenProcessed;
- (void)dispose;
- (void)finalize;
- (void)accept:(id)a0;
- (BOOL)hasTabs;
- (void)setLevels:(int)a0;
- (void)setBaseline:(double)a0;
- (BOOL)overlapsWith:(id)a0;
- (void)fitBoundsToChildren;
- (void)translateObjectYBy:(double)a0;
- (BOOL)isIndivisible;
- (BOOL)isMonospaced;
- (unsigned int)inlineCount;
- (BOOL)styleIsUniform:(struct CPPDFStyle **)a0 styleFlags:(unsigned short)a1;
- (id)charSequence;
- (double)monospaceWidth;
- (BOOL)hasDropCap;
- (struct CPInlineContainer { unsigned int x0; id x1; struct CPInlineContainer *x2; } *)inlineList;
- (struct { unsigned int x0; unsigned int x1; int x2; int x3; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x4; } *)wordAtIndex:(unsigned int)a0;
- (unsigned int)spacesBeforeWordAtIndex:(unsigned int)a0;
- (struct { unsigned int x0; unsigned int x1; int x2; int x3; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x4; } *)firstWord;
- (void)setCharSequence:(id)a0;
- (struct { unsigned int x0; unsigned int x1; int x2; int x3; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x4; } *)wordArrayOfSize:(unsigned int)a0;
- (void)recomputeLevels;
- (id)newTextLineFromWordAt:(unsigned int)a0 lengthInWords:(unsigned int)a1;
- (void)recomputeBaseline;
- (BOOL)overlapsHorizontally:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (BOOL)mapToWordsWithIndex:(void /* function */ *)a0 passing:(void *)a1;
- (struct { unsigned int x0; unsigned int x1; int x2; int x3; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x4; } *)wordArray;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsOfWordAtIndex:(unsigned int)a0;
- (void)anchorChunk:(id)a0 atWordIndex:(unsigned int)a1;
- (BOOL)hasJustifiedAlignment;
- (BOOL)changesFontAt:(id)a0;
- (BOOL)removeTextLines:(id)a0 whereTrue:(void /* function */ *)a1 passing:(void *)a2;
- (BOOL)mapToWords:(void /* function */ *)a0 passing:(void *)a1;
- (BOOL)mapToWordPairs:(void /* function */ *)a0 passing:(void *)a1;
- (BOOL)mapToWordPairsWithIndex:(void /* function */ *)a0 passing:(void *)a1;
- (void)setHasBeenSplit:(BOOL)a0;
- (BOOL)hasBeenSplit;
- (void)setHasBeenProcessed:(BOOL)a0;
- (id)columnBreaks;
- (void)setColumnBreaks:(id)a0;
- (void)setHasTabs:(BOOL)a0;
- (void)setTabsBefore:(int)a0;
- (int)tabsBefore;
- (long long)baseLineAscending:(id)a0;
- (long long)baseLineDescending:(id)a0;
- (BOOL)hyphenated;
- (void)setBaselineToNull;
- (void)setSpaces:(unsigned int)a0 beforeWordAtIndex:(unsigned int)a1;
- (float)maximumLetterGap;
- (void)setMaximumLetterGap:(float)a0;
- (float)maximumWordGap;
- (void)setMaximumWordGap:(float)a0;
- (BOOL)irregular;
- (void)setIrregular:(BOOL)a0;
- (long long)topIsAbove:(id)a0;
- (double)medianFontSize;

@end
