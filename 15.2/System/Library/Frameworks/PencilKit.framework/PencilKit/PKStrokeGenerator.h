@class PKStroke, NSObject;
@protocol OS_dispatch_queue, OS_dispatch_semaphore;

@interface PKStrokeGenerator : NSObject <PKInputProvider> {
    double _latestNonPredictedTimestamp;
    struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *__begin_; struct *__end_; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct *__value_; } __end_cap_; } _drawPoints;
    struct vector<_PKStrokePoint, std::allocator<_PKStrokePoint>> { struct _PKStrokePoint *__begin_; struct _PKStrokePoint *__end_; struct __compressed_pair<_PKStrokePoint *, std::allocator<_PKStrokePoint>> { struct _PKStrokePoint *__value_; } __end_cap_; } _outputPoints;
    long long _outputImmutableCount;
    BOOL _inputHasChanged;
    struct _PKStrokePoint { double timestamp; struct CGPoint { double x; double y; } location; double radius; double aspectRatio; double edgeWidth; double force; double azimuth; double altitude; double opacity; } _baseValues;
    NSObject<OS_dispatch_queue> *_inputQueue;
    PKStroke *_currentStroke;
    long long _currentInputType;
    unsigned long long _currentActiveInputProperties;
    long long _immutableCount;
    long long _missedUpdates;
    struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *__begin_; struct *__end_; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct *__value_; } __end_cap_; } _updatedDrawPoints;
    BOOL _drawingEndedButNotFinished;
    NSObject<OS_dispatch_semaphore> *_drawingWaitForFinishSemaphore;
    BOOL _keepPredictedTouchesAtEndOfStroke;
}

@property (nonatomic) struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } rulerTransform;
@property (nonatomic) BOOL useRuler;
@property (nonatomic) double rulerWidth;
@property (nonatomic) BOOL isSnappedToRulerTopSide;
@property (nonatomic) BOOL canSnapToRuler;
@property (nonatomic) double strokeMaxForce;
@property struct CGPoint { double x; double y; } lastPoint;
@property (retain, nonatomic) NSObject<OS_dispatch_queue> *outputQueue;
@property (nonatomic) double touchSensitivity;
@property (nonatomic) void *inputProvider;
@property (nonatomic) void *pixelSmoothingFilter;
@property (nonatomic) void *pointReductionFilter;
@property (nonatomic) void *startHookFilter;
@property (nonatomic) void *endHookFilter;
@property (nonatomic) void *velocityFilter;
@property (nonatomic) void *inputSmoother;
@property (nonatomic) void *inputToOutputFilter;
@property (nonatomic) void *startCapFilter;
@property (nonatomic) void *azimuthFilter;
@property (nonatomic) void *endCapFilter;
@property (nonatomic) void *rulerExtremaFilter;
@property (nonatomic) void *estimatedAltitudeAndAzimuthFilter;
@property (nonatomic) void *compressionFilter;
@property (nonatomic) void *decompressionFilter;
@property BOOL isSnappedToRuler;
@property (readonly) BOOL lastPointIsMasked;
@property double eraserIndicatorAlpha;
@property (nonatomic) double inputScale;
@property (readonly, nonatomic) long long inputType;
@property (readonly, nonatomic) unsigned long long activeInputProperties;

+ (void)initialize;
+ (struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *x0; struct *x1; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct *x0; } x2; })inputPointsFromPoints:(const void *)a0 velocityForDistanceFunction:(id /* block */)a1;
+ (struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *x0; struct *x1; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct *x0; } x2; })inputPointsFromPath:(struct CGPath { } *)a0 maxSegmentLength:(double)a1 velocityForDistanceFunction:(id /* block */)a2;

- (long long)inputType;
- (void).cxx_destruct;
- (id)init;
- (void)addPoint:(struct { struct CGPoint { double x0; double x1; } x0; double x1; double x2; double x3; double x4; double x5; BOOL x6; long long x7; double x8; BOOL x9; })a0;
- (void)addPoints:(struct vector<PKInputPoint, std::allocator<PKInputPoint>> { struct *x0; struct *x1; struct __compressed_pair<PKInputPoint *, std::allocator<PKInputPoint>> { struct *x0; } x2; })a0;
- (void)dealloc;
- (void)reset;
- (id).cxx_construct;
- (double)latestTimestamp;
- (id)newStrokeWithCurrentData;
- (id)newStrokeWithCurrentDataCopy;
- (void)drawingBeganWithStroke:(id)a0 inputType:(long long)a1 activeInputProperties:(unsigned long long)a2 inputScale:(double)a3 start:(id /* block */)a4;
- (void)drawingUpdatePoint:(struct { struct CGPoint { double x0; double x1; } x0; double x1; double x2; double x3; double x4; double x5; BOOL x6; long long x7; double x8; BOOL x9; })a0;
- (void)drawingEndedWithCompletion:(id /* block */)a0;
- (void)drawingCancelledWithCompletion:(id /* block */)a0;
- (double)latestNonPredictedTimestamp;
- (id)strokeFromPath:(struct CGPath { } *)a0 ink:(id)a1 inputScale:(double)a2 maxSegmentLength:(double)a3 velocityForDistanceFunction:(id /* block */)a4 strokeClass:(Class)a5;
- (void)allowSnappingToRuler:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0 width:(double)a1;
- (long long)fetchFilteredPointsFromIndex:(long long)a0 accessBlock:(id /* block */)a1;
- (id)strokeFromPoints:(const void *)a0 sourceStroke:(id)a1 inputScale:(double)a2 averageInputPoint:(struct { struct CGPoint { double x0; double x1; } x0; double x1; double x2; double x3; double x4; double x5; BOOL x6; long long x7; double x8; BOOL x9; })a3;
- (void *)outputFilter;
- (double)distanceToRulerCenter:(struct CGPoint { double x0; double x1; })a0;
- (struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; })outputCurrentStrokePoint:(struct { struct CGPoint { double x0; double x1; } x0; double x1; double x2; double x3; double x4; double x5; BOOL x6; long long x7; double x8; BOOL x9; })a0;
- (struct CGPoint { double x0; double x1; })snapPointToRuler:(struct CGPoint { double x0; double x1; })a0;
- (struct CGPoint { double x0; double x1; })getRulerSnapLineOriginAndTangent:(struct CGPoint { double x0; double x1; } *)a0 andNormal:(struct CGPoint { double x0; double x1; } *)a1;
- (BOOL)shouldSnapPointToRuler:(struct CGPoint { double x0; double x1; })a0;
- (void)snapToRuler;
- (void)maskToRuler;
- (unsigned long long)copyInputUpdatedRangeFromIndex:(unsigned long long)a0 into:(void *)a1;
- (struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; })outputPoint:(struct { struct CGPoint { double x0; double x1; } x0; double x1; double x2; double x3; double x4; double x5; BOOL x6; long long x7; double x8; BOOL x9; })a0 baseValues:(struct _PKStrokePoint { double x0; struct CGPoint { double x0; double x1; } x1; double x2; double x3; double x4; double x5; double x6; double x7; double x8; })a1;
- (id)_newStrokeWithCurrentDataAndStrokeDataUUID:(id)a0;
- (void)drawingUpdateAllPoints;
- (void)drawingUpdateAllPointsDidTimeoutWithStrokeUUID:(id)a0;
- (void)_updatePredictedTouches;
- (void)updateImmutableCount;
- (void)_drawingAddPoint:(struct { struct CGPoint { double x0; double x1; } x0; double x1; double x2; double x3; double x4; double x5; BOOL x6; long long x7; double x8; BOOL x9; })a0;
- (void)_removePredictedTouches;
- (void)updateRulerSnapping;
- (id)strokeFromInputPoints:(void *)a0 inputType:(long long)a1 ink:(id)a2 inputScale:(double)a3 strokeClass:(Class)a4;
- (id)strokeFromPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(unsigned long long)a1 ink:(id)a2 inputScale:(double)a3 strokeClass:(Class)a4;
- (void *)getUpdatedRangeFromIndex:(inout unsigned long long *)a0;
- (void *)getInputUpdatedRangeFromIndex:(inout unsigned long long *)a0;
- (void)closeStroke;
- (id)strokeFromLineSegments:(const void *)a0 maxSegmentLength:(double)a1 ink:(id)a2 inputScale:(double)a3 strokeClass:(Class)a4;

@end
