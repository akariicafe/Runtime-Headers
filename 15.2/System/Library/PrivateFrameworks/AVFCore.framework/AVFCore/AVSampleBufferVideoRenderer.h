@class NSError, NSString, NSArray, AVSampleBufferRenderSynchronizer, AVSampleBufferDisplayLayer, AVMediaDataRequester, NSObject, NSMutableArray;
@protocol OS_dispatch_queue;

@interface AVSampleBufferVideoRenderer : NSObject <AVMediaDataRequesterConsumer, AVQueuedSampleBufferRenderingInternal> {
    struct OpaqueFigVideoQueue { } *_videoQueue;
    BOOL _outputObscured;
    long long _status;
    NSError *_error;
    AVSampleBufferDisplayLayer *_weakDisplayLayer;
    struct __CFArray { } *_figVideoTargets;
    BOOL _preventsDisplaySleepDuringVideoPlayback;
    BOOL _requiresFlushToResumeDecoding;
    BOOL _hasEverEnqueued;
    BOOL _isRequestingMediaData;
    AVMediaDataRequester *_mediaDataRequester;
    BOOL _aboveHighWaterLevel;
    NSObject<OS_dispatch_queue> *_serialQueue;
    NSObject<OS_dispatch_queue> *_videoQueueQueue;
    NSObject<OS_dispatch_queue> *_layerQueue;
    AVSampleBufferRenderSynchronizer *_weakReferenceToSynchronizer;
    BOOL _addedToSynchronizer;
    BOOL _controlTimebaseSetByUserIsInUse;
    struct OpaqueCMTimebase { } *_controlTimebaseSetByUser;
    struct OpaqueCMTimebase { } *_readOnlyVideoQueueTimebase;
    struct OpaqueCMTimebase { } *_readOnlyRenderingTimebase;
    NSMutableArray *_videoOutputs;
    NSObject<OS_dispatch_queue> *_flushCallbackListQueue;
    NSObject<OS_dispatch_queue> *_flushCallbackQueue;
    NSMutableArray *_flushCallbacks;
    NSObject<OS_dispatch_queue> *_queueForProtectingPrerollCompleteCallback;
    id /* block */ _pendingPrerollCompleteCallback;
    int _pendingPrerollRequestID;
    NSObject<OS_dispatch_queue> *_queueForCallingPrerollCompleteCallback;
    int _upcomingPTSExpectation;
    struct { long long value; int timescale; unsigned int flags; long long epoch; } _minimumUpcomingPTS;
    id _didFinishSuspensionNotificationToken;
}

@property (readonly) BOOL outputObscuredDueToInsufficientExternalProtection;
@property (nonatomic) BOOL preventsCapture;
@property (nonatomic) BOOL preventsDisplaySleepDuringVideoPlayback;
@property (readonly, nonatomic) NSArray *outputs;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

+ (void)initialize;
+ (BOOL)automaticallyNotifiesObserversForKey:(id)a0;

- (void)requestMediaDataWhenReadyOnQueue:(id)a0 usingBlock:(id /* block */)a1;
- (BOOL)isReadyForMoreMediaData;
- (void)flush;
- (void)removeOutput:(id)a0;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0;
- (void)copyFigSampleBufferAudioRenderer:(struct OpaqueFigSampleBufferAudioRenderer **)a0;
- (BOOL)setRenderSynchronizer:(id)a0 error:(id *)a1;
- (BOOL)hasSufficientMediaDataForReliablePlaybackStart;
- (long long)status;
- (void)addOutput:(id)a0;
- (id)videoPerformanceMetrics;
- (void)setSTSLabel:(id)a0;
- (void)setToneMapToStandardDynamicRange:(BOOL)a0;
- (struct OpaqueFigVideoQueue { } *)_copyVideoQueue;
- (int)_setContentLayerOnFigVideoQueue:(struct OpaqueFigVideoQueue { } *)a0;
- (struct OpaqueCMTimebase { } *)_readOnlyVideoQueueTimebase;
- (void)_setStatus:(long long)a0 error:(id)a1;
- (int)_initializeTimebases;
- (int)_createVideoQueue:(struct OpaqueFigVideoQueue **)a0;
- (void)_addFigVideoQueueListeners;
- (void)setControlTimebase:(struct OpaqueCMTimebase { } *)a0;
- (void)_callOldPrerollCompletionHandlerWithSuccess:(BOOL)a0 andSetNewPrerollCompletionHandler:(id /* block */)a1 forRequestID:(int)a2;
- (void)_flushComplete;
- (void)_removeFigVideoQueueListeners;
- (BOOL)_setSynchronizerTimebase:(struct OpaqueCMTimebase { } *)a0 error:(id *)a1;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; } *)a1;
- (void)flushWithRemovalOfDisplayedImage:(BOOL)a0 completionHandler:(id /* block */)a1;
- (void)_resetStatusWithOSStatus:(int)a0;
- (void)setDisplayLayerVisibility:(BOOL)a0;
- (void)_setRequiresFlushToResumeDecoding:(BOOL)a0;
- (void)resetUpcomingSampleBufferPresentationTimeExpectations;
- (BOOL)_hasEverEnqueued;
- (void)_updateVideoTargetsOnVideoQueue;
- (void)_setOutputObscuredDueToInsufficientExternalProtection:(BOOL)a0;
- (struct OpaqueCMTimebase { } *)controlTimebase;
- (int)_enqueueSingleSampleBuffer:(struct opaqueCMSampleBuffer { } *)a0 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; } *)a1;
- (void)flushAndRemoveImage;
- (void)prerollDecodeWithCompletionHandler:(id /* block */)a0;
- (void)_completedDecodeForPrerollForRequestID:(int)a0;
- (BOOL)requiresFlushToResumeDecoding;
- (void)addSampleBufferDisplayLayer:(id)a0;
- (BOOL)_setUpcomingPresentationTimeExpectations:(int)a0 minimumPresentationTime:(struct { long long x0; int x1; unsigned int x2; long long x3; })a1;
- (void)_updateVideoOutputs;
- (void)expectMinimumUpcomingSampleBufferPresentationTime:(struct { long long x0; int x1; unsigned int x2; long long x3; })a0;
- (void)expectMonotonicallyIncreasingUpcomingSampleBufferPresentationTimes;
- (void)stopRequestingMediaData;
- (void)_didFinishSuspension:(id)a0;
- (void)addVideoTarget:(struct OpaqueFigVideoTarget { } *)a0;
- (struct OpaqueCMTimebase { } *)timebase;
- (void).cxx_destruct;
- (id)init;
- (id)error;
- (void)dealloc;
- (void)_refreshAboveHighWaterLevel;

@end
