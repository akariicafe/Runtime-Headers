@class NSMutableDictionary, HDContentProtectionManager, HDProfile, NSDate, NSObject, NSDictionary, HDAssertionManager, HDDatabaseJournal, NSMutableArray, NSConditionLock, NSString, NSHashTable, NSMutableSet, HDHFDataStore, NSOperationQueue, HKObserverSet, NSLock, NSUUID;
@protocol OS_dispatch_queue, OS_dispatch_group, OS_dispatch_source;

@interface HDDatabase : NSObject <HDAssertionObserver, HDContentProtectionObserver, HDDiagnosticObject, HDSQLiteDatabaseDelegate, HDSQLiteDatabasePoolDelegate, HDSQLiteDatabaseProvider, HDDatabaseJournalDelegate, HDHFDataStoreDelegate, HDDatabaseMigrationTransactionDelegate, HDProfileReadyObserver, HDHealthDaemonReadyObserver, HDAnalyticsSubmissionCoordinatorDelegate, HDDatabaseCorruptionEventStoreDelegate, HDHealthDatabase> {
    _Atomic BOOL _invalidated;
    _Atomic BOOL _started;
    NSUUID *_databaseUUID;
    struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } _databaseUUIDLock;
    NSObject<OS_dispatch_queue> *_serialAsynchronousQueue;
    HDHFDataStore *_hfDataStore;
    NSLock *_writeLock;
    NSObject<OS_dispatch_queue> *_protectedDataQueue;
    HKObserverSet *_protectedDataObservers;
    long long _protectedDataState;
    long long _observedContentProtectionState;
    BOOL _isObservingContentProtection;
    NSObject<OS_dispatch_group> *_contentProtectionObservationGroup;
    NSObject<OS_dispatch_source> *_inactivityFlushTimer;
    BOOL _hasFlushedForInactivity;
    NSMutableArray *_firstUnlockBlocks;
    BOOL _shouldNotifyFirstUnlockObservers;
    NSDate *_protectedDataFlushDeadlineDate;
    NSObject<OS_dispatch_source> *_protectedDataFlushDeadlineTimer;
    BOOL _hasFlushedProtectedData;
    BOOL _disableTakingProtectedDataAssertionsWhenLocked;
    _Atomic BOOL _hasPendingSecondaryJournalMerge;
    NSMutableDictionary *_databaseJournalMergeObserverSetByType;
    NSHashTable *_protectedResourceStores;
    struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } _protectedResourceAssertionsLock;
    NSMutableDictionary *_protectedResourceAssertionsByIdentifier;
    struct atomic_flag { _Atomic BOOL _Value; } _hasFaultedForCorruptionError;
    NSString *_profileDirectoryPath;
    NSString *_threadLocalTransactionKey;
    NSString *_threadLocalTransactionContextKey;
    NSString *_threadLocalIgnoreTransactionContextKey;
    HDAssertionManager *_assertionManager;
    NSLock *_schemaMigrationLock;
    NSConditionLock *_activeDatabasesLock;
    NSMutableSet *_activeDatabases;
    NSHashTable *_migratedDatabases;
    NSOperationQueue *_asynchronousOperationQueue;
    NSObject<OS_dispatch_queue> *_journalQueue;
    NSObject<OS_dispatch_group> *_journalGroup;
    unsigned long long _pendingJournalMerges;
    NSObject<OS_dispatch_queue> *_secondaryJournalMergeQueue;
    NSMutableDictionary *_extendedTransactions;
    NSDictionary *_databasePoolForType;
}

@property (readonly, nonatomic) HDContentProtectionManager *contentProtectionManager;
@property (nonatomic) double offsetTimeInterval;
@property (nonatomic) double protectedDataFlushInterval;
@property (nonatomic) double inactivityFlushInterval;
@property (nonatomic) BOOL didRunPostMigrationUpdates;
@property (nonatomic) long long corruptedMigrationAttemptsCount;
@property (readonly, copy, nonatomic) NSDate *mostRecentObliterationDate;
@property (copy, nonatomic) id /* block */ unitTest_didWaitForJournalMergeHandler;
@property (readonly, nonatomic) HDDatabaseJournal *journal;
@property (readonly, nonatomic) HDDatabaseJournal *cloudSyncJournal;
@property (weak, nonatomic) HDProfile *profile;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, nonatomic, getter=isDataProtectedByFirstUnlockAvailable) BOOL dataProtectedByFirstUnlockAvailable;
@property (readonly, nonatomic, getter=isProtectedDataAvailable) BOOL protectedDataAvailable;

+ (id)allCurrentAndFutureEntityClasses;
+ (long long)unitTest_createOrMigrateDatabaseAtDirectoryURL:(id)a0 schemaProviders:(id)a1 behavior:(id)a2 error:(id *)a3;
+ (id)createDatabaseConnectionWithURL:(id)a0;
+ (id)allEntityClassesWithBehavior:(id)a0;

- (void)obliterateWithReason:(id)a0 preserveCopy:(BOOL)a1;
- (void)daemonReady:(id)a0;
- (void)unitTest_requestHFDRebuild:(BOOL)a0;
- (id)diagnosticDescription;
- (void)assertionManager:(id)a0 assertionInvalidated:(id)a1;
- (void)contentProtectionStateChanged:(long long)a0 previousState:(long long)a1;
- (id)databaseSizeInBytesForTypeUnprotected:(BOOL)a0 WAL:(BOOL)a1;
- (id)cloneAccessibilityAssertion:(id)a0 ownerIdentifier:(id)a1 error:(id *)a2;
- (void)_reportSQLiteCorruption:(id)a0 forDatabase:(long long)a1 shouldPrompt:(BOOL)a2;
- (unsigned long long)journalChapterCountForType:(long long)a0;
- (void)unitTest_enableDatabaseAccessibilityAssertions;
- (void)profileDidBecomeReady:(id)a0;
- (id)progressForJournalMergeWithType:(long long)a0;
- (void)unitTest_setContentProtectionStateAndWait:(long long)a0;
- (void)_reportDatabaseMigrationStatus:(long long)a0 component:(long long)a1 schemaVersion:(long long)a2 error:(id)a3;
- (void)checkInDatabase:(id)a0 type:(long long)a1 protectedResources:(id)a2;
- (id)databaseSizeInBytesExcludingHFD;
- (void)addProtectedDataObserver:(id)a0;
- (id)takeAccessibilityAssertionWithOwnerIdentifier:(id)a0 timeout:(double)a1 error:(id *)a2;
- (BOOL)allowMigrationToSQLiteForHFDataStore:(id)a0;
- (BOOL)migrateDataForHFDataStore:(id)a0 toSQLiteFrom:(const void *)a1 error:(id *)a2;
- (void)removeDatabaseJournalMergeObserver:(id)a0 journalType:(long long)a1;
- (void)HFDataStoreDidPerformRebuild:(id)a0 didDecompressArchivedHFD:(BOOL)a1 didOpenArchivedHFD:(BOOL)a2 didOpenMovedAsideHFD:(BOOL)a3 recoveryAnalytics:(id)a4 duration:(double)a5;
- (void)migrationTransaction:(id)a0 didCreateDatabasesWithIdentifier:(id)a1;
- (void)HFDataStore:(id)a0 detectedCorruptionOfType:(long long)a1 code:(int)a2 error:(id)a3 shouldPromptUser:(BOOL)a4 initialRebuildState:(long long)a5 updatedRebuildState:(long long)a6;
- (void)start;
- (id)checkOutUnprotectedDatabase:(id)a0 error:(id *)a1;
- (id)initWithProfile:(id)a0 concurrentReaderLimit:(unsigned long long)a1;
- (void)performWhenDataProtectedByFirstUnlockIsAvailable:(id /* block */)a0;
- (id)databaseUUIDWithError:(id *)a0;
- (void)addDatabaseJournalMergeObserver:(id)a0 journalType:(long long)a1 queue:(id)a2;
- (id)databasePoolForDatabaseType:(long long)a0;
- (void).cxx_destruct;
- (void)invalidateAndWait;
- (BOOL)performHighPriorityTransactionsWithError:(id *)a0 block:(id /* block */)a1;
- (void)finalizeExtendedTransactionForIdentifier:(id)a0;
- (id)HFDSizeInBytes;
- (id)newDatabaseForDatabasePool:(id)a0 error:(id *)a1;
- (id)store:(id)a0 objectForKey:(id)a1;
- (BOOL)performWithJournalType:(long long)a0 error:(id *)a1 block:(id /* block */)a2;
- (id)_newCorruptionEventStore;
- (BOOL)performTransactionWithContext:(id)a0 error:(id *)a1 block:(id /* block */)a2 inaccessibilityHandler:(id /* block */)a3;
- (void)performWhenDataProtectedByFirstUnlockIsAvailableOnQueue:(id)a0 block:(id /* block */)a1;
- (void)unitTest_disableDatabaseAccessibilityAssertions;
- (id)_journalForType:(long long)a0;
- (id)highFrequencyDataStoreURL;
- (BOOL)addJournalEntry:(id)a0 error:(id *)a1;
- (id)unitTest_HFDataStore;
- (BOOL)addJournalEntries:(id)a0 error:(id *)a1;
- (void)performAsynchronously:(id /* block */)a0;
- (id)beginExtendedTransactionWithContext:(id)a0 transactionTimeout:(double)a1 continuationTimeout:(double)a2 error:(id *)a3;
- (void)migrationTransaction:(id)a0 didEncounterDatabaseMismatchWithUnprotectedIdentifier:(id)a1 protectedIdentifier:(id)a2;
- (void)databaseJournalMergeDidComplete:(id)a0;
- (void)addProtectedDataObserver:(id)a0 queue:(id)a1;
- (void)store:(id)a0 setObject:(id)a1 forKey:(id)a2;
- (void)removeProtectedDataObserver:(id)a0;
- (void)requestRebuildTransactionForHFDataStore:(id)a0;
- (void)HFDataStoreDetectedOutOfSpace:(id)a0;
- (id)extendedDatabaseTransactionForIdentifier:(id)a0;
- (id)allEntityClassesWithProtectionClass:(long long)a0;
- (void)reportDailyAnalyticsWithCoordinator:(id)a0 completion:(id /* block */)a1;
- (void)HFDataStore:(id)a0 setInteger:(long long)a1 forKey:(id)a2;
- (BOOL)performWithTransactionContext:(id)a0 error:(id *)a1 block:(id /* block */)a2;
- (id)unitTest_currentTransaction;
- (void)dealloc;
- (void)databasePool:(id)a0 didFlushDatabases:(id)a1;
- (BOOL)accessHighFrequencyDataStoreWithError:(id *)a0 block:(id /* block */)a1;
- (id)takeAccessibilityAssertionWithOwnerIdentifier:(id)a0 shouldPerformTransaction:(BOOL)a1 timeout:(double)a2 error:(id *)a3;
- (BOOL)migrateDataForHFDataStore:(id)a0 from:(const void *)a1 to:(void *)a2 recoveryAnalytics:(id)a3 error:(id *)a4;
- (BOOL)discardHighFrequencyDataStoreWithError:(id *)a0;
- (id)activeTransactionForCurrentThreadForHFDataStore:(id)a0 forWriting:(BOOL)a1;
- (void)didMigrateHFDataStore:(id)a0 fromState:(long long)a1 toState:(long long)a2 success:(BOOL)a3 error:(id)a4;
- (id)_newDataStoreForPath:(id)a0;
- (id)checkOutProtectedResources:(id)a0 error:(id *)a1;
- (long long)HFDataStore:(id)a0 integerForKey:(id)a1;
- (id)checkOutProtectedDatabase:(id)a0 error:(id *)a1;
- (void)performAsynchronouslySerial:(id /* block */)a0;

@end
