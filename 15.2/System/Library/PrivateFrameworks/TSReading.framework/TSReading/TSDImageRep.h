@class TSDImageRepSizingState, NSString, NSRecursiveLock, NSCache, CALayer, CAShapeLayer, NSObject, NSMutableArray, TSDInstantAlphaTracker, TSDLayoutGeometry;
@protocol OS_dispatch_queue, OS_dispatch_semaphore;

@interface TSDImageRep : TSDMediaRep <CALayerDelegate, TSDMagicMoveMatching> {
    TSDLayoutGeometry *mLastImageGeometryInRoot;
    TSDLayoutGeometry *mLastMaskGeometryInRoot;
    struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } mLastLayoutToImageTransform;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } mFrameInUnscaledCanvasRelativeToSuper;
    BOOL mFrameInUnscaledCanvasIsValid;
    CALayer *mContentsLayer;
    CAShapeLayer *mMaskPathLayer;
    CAShapeLayer *mIAMaskLayer;
    CAShapeLayer *mMaskSublayer;
    struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } mLastPictureFrameLayerTransform;
    BOOL mDirectlyManagesLayerContent;
    BOOL mShowImageHighlight;
    BOOL mInInstantAlphaMode;
    TSDInstantAlphaTracker *mInstantAlphaTracker;
    struct CGImage { } *mInstantAlphaImage;
    struct CGAffineTransform { double a; double b; double c; double d; double tx; double ty; } mBaseMaskLayoutTransform;
    NSRecursiveLock *mLayerUpdateAndSizingStateLock;
    TSDImageRepSizingState *mSizingState;
    BOOL mSizingStateReady;
    NSObject<OS_dispatch_queue> *mSizedImageAccessQueue;
    struct CGImage { } *mSizedImage;
    struct CGSize { double width; double height; } mSizedImageSize;
    long long mSizedImageOrientation;
    BOOL mSizedImageHasMaskBakedIn;
    BOOL mSizedImageHasAdjustmentsBakedIn;
    struct CGPath { } *mSizedImageMaskPath;
    struct CGImage { } *mCachedSizedImage;
    struct CGSize { double width; double height; } mCachedSizedImageSize;
    long long mCachedSizedImageOrientation;
    NSCache *mHitTestCache;
    long long mHitTestCacheOnce;
    NSMutableArray *mUpdateFromLayoutBlocks;
    NSObject<OS_dispatch_semaphore> *mUpdateFromLayoutBlocksLock;
    unsigned long long mImageSizingDisabledCount;
}

@property (readonly, nonatomic) struct CGImage { } *imageRef;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

+ (double)magicMoveAttributeMatchPercentBetweenOutgoingObject:(id)a0 incomingObject:(id)a1;
+ (struct CGPath { } *)p_newPathToBakeIntoSizedImageForSize:(struct CGSize { double x0; double x1; })a0 withImageLayout:(id)a1 orientation:(long long)a2;

- (BOOL)isDraggable;
- (BOOL)containsPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)willBeRemoved;
- (void)highlightImage;
- (id)imageInfo;
- (BOOL)shouldShowShadow;
- (id)contentsLayer;
- (void)dealloc;
- (void)viewScaleDidChange;
- (BOOL)directlyManagesLayerContent;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })frameInUnscaledCanvas;
- (void)didUpdateLayer:(id)a0;
- (void)processChangedProperty:(int)a0;
- (id)imageLayout;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })targetRectForEditMenu;
- (void)willBeginReadMode;
- (BOOL)handleDoubleTapAtPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)processChanges:(id)a0;
- (void)i_willEnterForeground;
- (void)wideGamutValueDidChange;
- (void)didCreateLayer:(id)a0;
- (void)willUpdateLayer:(id)a0;
- (void)updateLayerGeometryFromLayout:(id)a0;
- (id)additionalLayersOverLayer;
- (id)overlayLayers;
- (void)drawInLayerContext:(struct CGContext { } *)a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsForStandardKnobs;
- (id)hitRepChrome:(struct CGPoint { double x0; double x1; })a0;
- (void)layoutInRootChangedFrom:(id)a0 to:(id)a1 translatedOnly:(BOOL)a2;
- (void)addKnobsToArray:(id)a0;
- (void)updatePositionsOfKnobs:(id)a0;
- (BOOL)shouldCreateSelectionKnobs;
- (struct CGPoint { double x0; double x1; })positionOfStandardKnob:(id)a0 forBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsForHighlightLayer;
- (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })transformForHighlightLayer;
- (BOOL)shouldShowSelectionHighlight;
- (struct CGPoint { double x0; double x1; })centerForRotation;
- (BOOL)canDrawInParallel;
- (id)initWithLayout:(id)a0 canvas:(id)a1;
- (void)updateFromLayout;
- (void)addBitmapsToRenderingQualityInfo:(id)a0 inContext:(struct CGContext { } *)a1;
- (void)becameNotSelected;
- (double)additionalRotationForKnobOrientation;
- (BOOL)shouldIgnoreEditMenuTapAtPoint:(struct CGPoint { double x0; double x1; })a0 withRecognizer:(id)a1;
- (id)textureForContext:(id)a0;
- (BOOL)shouldShowDragHUD;
- (int)dragTypeAtCanvasPoint:(struct CGPoint { double x0; double x1; })a0;
- (BOOL)wantsToDistortWithImagerContext;
- (void)drawInContextWithoutEffects:(struct CGContext { } *)a0 withContent:(BOOL)a1 withStroke:(BOOL)a2 withOpacity:(BOOL)a3 forAlphaOnly:(BOOL)a4 drawChildren:(BOOL)a5;
- (id)imageOfStroke:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } *)a0;
- (id)pathSourceForSelectionHighlightBehavior;
- (BOOL)canDrawShadowInOneStepWithChildren:(BOOL)a0;
- (void)p_updateDirectlyManagesLayerContentForLayer:(id)a0;
- (void)p_disposeStrokeLayer;
- (void)p_disposeMaskLayer;
- (id)maskInfo;
- (id)maskLayout;
- (BOOL)p_hitCacheGetCachedValue:(BOOL *)a0 forPoint:(struct CGPoint { double x0; double x1; })a1;
- (void)p_drawInContext:(struct CGContext { } *)a0 withContent:(BOOL)a1 withStroke:(BOOL)a2 withOpacity:(double)a3 withMask:(BOOL)a4 withIAMask:(BOOL)a5 forLayer:(BOOL)a6 forShadow:(BOOL)a7 forHitTest:(BOOL)a8;
- (void)p_hitCacheSetCachedValue:(BOOL)a0 forPoint:(struct CGPoint { double x0; double x1; })a1;
- (void)p_invalidateSizedImage;
- (BOOL)shouldShowSmartMaskKnobs;
- (id)p_validatedBitmapImageProvider;
- (void)p_invalidateSizedImageFromQueue;
- (void)p_invalidateHitTestCache;
- (BOOL)shouldShowMediaReplaceUI;
- (BOOL)shouldAllowReplacementFromPaste;
- (struct CGImage { } *)p_newImageByApplyingAdjustmentsToImage:(struct CGImage { } *)a0 alreadyEnhanced:(BOOL)a1;
- (id)p_validatedThumbnailImageProvider;
- (id)p_validatedImageProvider;
- (id)p_imageData;
- (struct CGSize { double x0; double x1; })p_desiredSizedImageSize;
- (void)p_generateSizedImageIfNecessary;
- (void)p_takeSizedImageFromStateIfReady;
- (BOOL)p_directlyManagesContentForLayer:(id)a0;
- (struct CGImage { } *)p_imageForDirectlyManagedLayer:(id)a0;
- (BOOL)p_shouldRenderWithMaskToBounds;
- (void)p_getAliasedValuesForMaskToBoundsDirectLayerFrame:(out struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } *)a0 transform:(out struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; } *)a1;
- (long long)p_orientationForDirectlyManagedLayer;
- (void)p_createMaskLayerForLayer:(id)a0;
- (BOOL)p_shouldBakeMaskIntoSizedImage;
- (void)p_updateStrokeLayerForStroke:(id)a0 repLayer:(id)a1;
- (BOOL)p_shouldMaskWithFrameLayers;
- (void)p_updateMaskSublayersForMaskEditMode;
- (void)p_updateMaskLayer:(id)a0 forRepLayer:(id)a1 shouldIncludeMask:(BOOL)a2 shouldIncludeInstantAlpha:(BOOL)a3;
- (id)p_imageProvider;
- (BOOL)p_drawsInOneStep;
- (BOOL)p_okayToGenerateSizedImage;
- (void)p_takeSizedImageFromCache;
- (void)p_startSizing;
- (void)p_generateSizedImage:(id)a0;
- (void)p_takeSizedImageFromState;
- (BOOL)p_takeSizedImageFromState:(id)a0;
- (void)unhighlightImage;
- (void)p_canvasSelectionDidChange:(id)a0;
- (void)pushDisableImageSizing;
- (void)popDisableImageSizing;
- (void)cacheImageAtCurrentSize;
- (id)newCachedSizedImage;
- (id)newCachedSizedImageWithNaturalSize;
- (void)useCachedSizedImage:(id)a0;
- (void)generateSizedImageOnBackgroundThread;
- (void)p_popoverViewPresented:(id)a0;

@end
