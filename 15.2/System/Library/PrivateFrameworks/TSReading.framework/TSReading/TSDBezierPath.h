@interface TSDBezierPath : NSObject <NSCopying, NSSecureCoding> {
    long long sfr_elementCount;
    long long sfr_elementMax;
    struct PATHSEGMENT { unsigned char x0 : 4; unsigned long x1 : 60; struct CGPoint { double x0; double x1; } x2; } *sfr_head;
    double *sfr_elementLength;
    double sfr_totalLength;
    long long sfr_lastSubpathIndex;
    void *sfr_extraSegments;
    double sfr_lineWidth;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } sfr_controlPointBounds;
    double sfr_miterLimit;
    double sfr_flatness;
    double *sfr_dashedLinePattern;
    unsigned long long sfr_dashedLineCount;
    double sfr_dashedLinePhase;
    void *sfr_path;
    long long sfr_extraSegmentCount;
    long long sfr_extraSegmentMax;
    struct { unsigned char sfr_flags : 8; unsigned char sfr_pathState : 2; unsigned char sfr_calculatedLengths : 1; unsigned int sfr_unused : 21; } sfr_bpFlags;
}

@property (class, readonly) BOOL supportsSecureCoding;

@property (readonly, nonatomic) BOOL isCompound;
@property (readonly, nonatomic) BOOL isSelfIntersecting;
@property (readonly, nonatomic) BOOL isOpen;
@property (readonly, nonatomic) BOOL isLineSegment;
@property (readonly, nonatomic) BOOL isEffectivelyClosed;
@property (readonly, nonatomic) BOOL containsClosePathElement;

+ (void)setLineWidth:(double)a0;
+ (void)initialize;
+ (double)lineWidth;
+ (void)fillRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (double)flatness;
+ (id)bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
+ (id)bezierPath;
+ (double)miterLimit;
+ (unsigned long long)lineCapStyle;
+ (void)setMiterLimit:(double)a0;
+ (void)setFlatness:(double)a0;
+ (id)bezierPathWithCGPath:(struct CGPath { } *)a0;
+ (unsigned long long)lineJoinStyle;
+ (void)setLineJoinStyle:(unsigned long long)a0;
+ (void)setLineCapStyle:(unsigned long long)a0;
+ (void)strokeRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)outlineBezierPath:(id)a0 withThreshold:(double)a1;
+ (id)uniteBezierPaths:(id)a0;
+ (id)exteriorOfBezierPath:(id)a0;
+ (unsigned long long)windingRule;
+ (void)setWindingRule:(unsigned long long)a0;
+ (id)bezierPathWithStart:(struct CGPoint { double x0; double x1; })a0 end:(struct CGPoint { double x0; double x1; })a1;
+ (void)clipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (void)strokeLineFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1;
+ (void)setDefaultMiterLimit:(double)a0;
+ (double)defaultMiterLimit;
+ (void)setDefaultFlatness:(double)a0;
+ (double)defaultFlatness;
+ (void)setDefaultWindingRule:(unsigned long long)a0;
+ (unsigned long long)defaultWindingRule;
+ (void)setDefaultLineCapStyle:(unsigned long long)a0;
+ (unsigned long long)defaultLineCapStyle;
+ (void)setDefaultLineJoinStyle:(unsigned long long)a0;
+ (unsigned long long)defaultLineJoinStyle;
+ (void)setDefaultLineWidth:(double)a0;
+ (double)defaultLineWidth;
+ (id)outsideEdgeOfBezierPath:(id)a0;
+ (id)tracedPathForImage:(struct CGImage { } *)a0 alphaThreshold:(double)a1 pointSpacing:(double)a2;
+ (id)outlineBezierPath:(id)a0;
+ (id)subtractBezierPaths:(id)a0;
+ (id)intersectBezierPaths:(id)a0;
+ (id)bezierPathWithConvexHullOfPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(unsigned long long)a1;
+ (id)p_booleanWithBezierPaths:(id)a0 operation:(int)a1;
+ (struct Path { int x0; int x1; int x2; struct path_descr *x3; int x4; int x5; BOOL x6; BOOL x7; int x8; int x9; int x10; char *x11; } *)p_bezierToPath:(id)a0;
+ (id)p_pathToBezier:(struct Path { int x0; int x1; int x2; struct path_descr *x3; int x4; int x5; BOOL x6; BOOL x7; int x8; int x9; int x10; char *x11; } *)a0;
+ (id)excludeBezierPaths:(id)a0;
+ (id)appendBezierPaths:(id)a0;
+ (id)smoothBezierPath:(id)a0 withThreshold:(double)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })p_pathToBounds:(struct Path { int x0; int x1; int x2; struct path_descr *x3; int x4; int x5; BOOL x6; BOOL x7; int x8; int x9; int x10; char *x11; } *)a0;
+ (id)tracedPathForInstantAlphaBinaryBitmap:(id)a0 pointSpacing:(double)a1;

- (void)setLineWidth:(double)a0;
- (void)fill;
- (double)lineWidth;
- (struct CGPath { } *)CGPath;
- (void)stroke;
- (BOOL)isFlat;
- (void)addClip;
- (double)length;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3 clockwise:(BOOL)a4;
- (void)encodeWithCoder:(id)a0;
- (double)flatness;
- (void)closePath;
- (BOOL)containsPoint:(struct CGPoint { double x0; double x1; })a0;
- (id)description;
- (unsigned long long)elementAtIndex:(long long)a0;
- (void)setLineDash:(const double *)a0 count:(long long)a1 phase:(double)a2;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })bounds;
- (double)miterLimit;
- (unsigned long long)lineCapStyle;
- (void)setMiterLimit:(double)a0;
- (BOOL)isEmpty;
- (void)setFlatness:(double)a0;
- (void)removeAllPoints;
- (BOOL)isEqual:(id)a0;
- (void)appendBezierPath:(id)a0;
- (unsigned long long)lineJoinStyle;
- (void)setLineJoinStyle:(unsigned long long)a0;
- (void)appendBezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (id)bezierPathByReversingPath;
- (void)getLineDash:(double *)a0 count:(long long *)a1 phase:(double *)a2;
- (void)appendBezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)setLineCapStyle:(unsigned long long)a0;
- (void)moveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (id)init;
- (id)initWithCoder:(id)a0;
- (BOOL)isCircular;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (void)lineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (id)pressure;
- (void)dealloc;
- (void)_doPath;
- (id)chisel;
- (struct CGPoint { double x0; double x1; })currentPoint;
- (long long)elementCount;
- (const char *)cString;
- (id)initWithCString:(const char *)a0;
- (void)transformUsingAffineTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0;
- (id)uniteWithBezierPath:(id)a0;
- (BOOL)isRectangular;
- (id)bezierPathByOffsettingPath:(double)a0 joinStyle:(unsigned long long)a1 withThreshold:(double)a2;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (unsigned long long)elementAtIndex:(long long)a0 associatedPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (unsigned long long)windingRule;
- (void)setWindingRule:(unsigned long long)a0;
- (void)_deviceMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)_deviceClosePath;
- (void)subdivideBezierWithFlatness:(double)a0 startPoint:(struct CGPoint { double x0; double x1; })a1 controlPoint1:(struct CGPoint { double x0; double x1; })a2 controlPoint2:(struct CGPoint { double x0; double x1; })a3 endPoint:(struct CGPoint { double x0; double x1; })a4;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })controlPointBounds;
- (unsigned long long)elementAtIndex:(long long)a0 allPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (double)calculateLengthOfElement:(long long)a0;
- (void)calculateLengths;
- (void)_appendToPath:(id)a0;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3;
- (void)_appendArcSegmentWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 angle1:(double)a2 angle2:(double)a3;
- (void)relativeMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (id)bezierPathByFlatteningPath;
- (id)_copyFlattenedPath;
- (BOOL)isClockwise;
- (double)lengthOfElement:(long long)a0;
- (double)lengthToElement:(long long)a0;
- (void)setAssociatedPoints:(struct CGPoint { double x0; double x1; } *)a0 atIndex:(long long)a1;
- (void)appendBezierPathWithPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(long long)a1;
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1 radius:(double)a2;
- (void)_addPathSegment:(long long)a0 point:(struct CGPoint { double x0; double x1; })a1;
- (void)getStartPoint:(struct CGPoint { double x0; double x1; } *)a0 andEndPoint:(struct CGPoint { double x0; double x1; } *)a1;
- (void)addIntersectionsWithPath:(id)a0 to:(id)a1 allIntersections:(BOOL)a2 reversed:(BOOL)a3;
- (void)appendBezierPath:(id)a0 fromSegment:(long long)a1 t:(double)a2 toSegment:(long long)a3 t:(double)a4 withoutMove:(BOOL)a5;
- (void)recursiveSubdivideOntoPath:(id)a0 withScaling:(struct { double x0; double x1; })a1 inElementRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a2 into:(id)a3;
- (struct CGPoint { double x0; double x1; })rawGradientAt:(float)a0 fromElement:(long long)a1;
- (long long)elementPercentage:(float *)a0 forOverallPercentage:(float)a1;
- (struct CGPoint { double x0; double x1; })gradientAt:(double)a0 fromElement:(long long)a1;
- (struct CGPoint { double x0; double x1; })pointAt:(double)a0 fromElement:(long long)a1;
- (float)elementPercentageFromElement:(int)a0 forOverallPercentage:(float)a1;
- (double)curvatureAt:(double)a0 fromElement:(int)a1;
- (struct CGPoint { double x0; double x1; })transformedTotalCoordinate:(struct CGPoint { double x0; double x1; })a0 betweenElement:(long long)a1 andElement:(long long)a2 withPressure:(id)a3 getElement:(long long *)a4 getPercentage:(float *)a5;
- (struct CGPoint { double x0; double x1; })myGradientAt:(float)a0 fromElement:(long long)a1;
- (void)addIntersectionsWithPath:(id)a0 to:(id)a1;
- (void)addIntersectionsWithLine:(struct CGPoint { double x0; double x1; }[2])a0 to:(id)a1;
- (void)appendBezierPath:(id)a0 fromSegment:(long long)a1 toSegment:(long long)a2;
- (id)copyFromSegment:(int)a0 t:(float)a1 toSegment:(int)a2 t:(float)a3;
- (struct CGPoint { double x0; double x1; })nearestPointOnPathToLine:(struct CGPoint { double x0; double x1; }[2])a0;
- (struct CGPoint { double x0; double x1; })nearestAngleOnPathToLine:(struct CGPoint { double x0; double x1; }[2])a0;
- (struct CGPoint { double x0; double x1; })gradientAt:(float)a0;
- (struct CGPoint { double x0; double x1; })transformedCoordinate:(struct CGPoint { double x0; double x1; })a0 withPressure:(id)a1;
- (struct CGPoint { double x0; double x1; })transformedTotalCoordinate:(struct CGPoint { double x0; double x1; })a0 inElement:(long long)a1 withPressure:(id)a2;
- (struct CGPoint { double x0; double x1; })myGradientAt:(float)a0;
- (float)curvatureAt:(float)a0;
- (void)recursiveSubdivideOntoPath:(id)a0 into:(id)a1;
- (void)recursiveSubdivideOntoPath:(id)a0 withScaling:(struct { double x0; double x1; })a1 into:(id)a2;
- (void)copyPathAttributesTo:(id)a0;
- (void)flattenIntoPath:(id)a0 flatness:(double)a1;
- (id)bezierPathByFlatteningPathWithFlatness:(double)a0;
- (id)bezierPathByRemovingRedundantElements;
- (BOOL)isTriangular;
- (BOOL)isDiamond;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 startAngle:(double)a1 swingAngle:(double)a2 angleType:(int)a3 startNewPath:(BOOL)a4;
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 startRadialVector:(struct CGPoint { double x0; double x1; })a1 endRadialVector:(struct CGPoint { double x0; double x1; })a2 angleSign:(int)a3 startNewPath:(BOOL)a4;
- (id)intersectBezierPath:(id)a0;
- (id)subtractBezierPath:(id)a0;
- (BOOL)intersectsRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 hasFill:(BOOL)a1;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsIncludingTSDStroke:(id)a0;
- (id)pathSplitAtSubpathBoundariesWithSoftElementLimit:(unsigned long long)a0 hardElementLimit:(unsigned long long)a1;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsIncludingStroke;
- (id)outlineStroke;
- (long long)elementPercentage:(double *)a0 forOverallPercentage:(double)a1 startingElementIndex:(long long)a2 lengthToStartingElement:(double)a3;
- (id)aliasedPathWithViewScale:(float)a0 effectiveStrokeWidth:(float)a1;
- (double)distanceToPoint:(struct CGPoint { double x0; double x1; })a0 elementIndex:(unsigned long long *)a1 tValue:(double *)a2 threshold:(double)a3;
- (void)takeAttributesFromStroke:(id)a0;
- (id)aliasedPathInContext:(struct CGContext { } *)a0 effectiveStrokeWidth:(float)a1;
- (double)yValueFromXValue:(double)a0 elementIndex:(long long *)a1 parametricValue:(double *)a2;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsIncludingStrokeWidth:(double)a0 joinStyle:(unsigned long long)a1 capStyle:(unsigned long long)a2 miterLimit:(double)a3 needsToExtendJoins:(BOOL)a4;
- (id)p_copyWithPointsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0 countingSubpaths:(unsigned long long *)a1;
- (id)p_elementCountForSubpaths;
- (id)copyWithPointsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a0;
- (void)addPathToContext:(struct CGContext { } *)a0;
- (id)p_aliasedPathInContext:(struct CGContext { } *)a0 viewScale:(float)a1 effectiveStrokeWidth:(float)a2;
- (id)pathBySplittingAtPointOnPath:(struct CGPoint { double x0; double x1; })a0;
- (double)yValueFromXValue:(double)a0;
- (void)alignBoundsToOrigin;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_addMitersFromSegments:(id)a0 toRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (BOOL)pointOnPath:(struct CGPoint { double x0; double x1; })a0 tolerance:(double)a1;
- (struct CGPoint { double x0; double x1; })pointAlongPathAtPercentage:(double)a0;
- (id)p_pathAsSegments;
- (id)p_beziersFromSegmentIntersections:(id)a0;
- (void)clearStroke:(struct CGContext { } *)a0;
- (id)pathByWobblingByUpTo:(double)a0 subdivisions:(unsigned long long)a1;
- (struct CGPoint { double x0; double x1; })roundPoint:(struct CGPoint { double x0; double x1; })a0 inContext:(struct CGContext { } *)a1 strokeWidth:(int)a2;
- (id)bezierPathByFittingCurve:(id)a0;
- (id)bezierPathByFittingCurve;

@end
