@interface NUCropModel : NSObject <NSCopying> {
    void /* unknown type, empty encoding */ _imageCenter;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _cropRect;
    double _pitchRadians;
    double _yawRadians;
    double _rollRadians;
}

@property (readonly, nonatomic) BOOL hasOvercapture;
@property (nonatomic) double pitchRadians;
@property (nonatomic) double yawRadians;
@property (nonatomic) double rollRadians;
@property (readonly, nonatomic) struct CGSize { double x0; double x1; } masterImageSize;
@property (readonly, nonatomic) struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } masterImageRect;
@property (readonly, nonatomic) double fovRadians;
@property (readonly, nonatomic) struct CGSize { double x0; double x1; } stitchedImageSize;
@property (readonly, nonatomic) struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } stitchedImageRect;
@property struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } cropRect;
@property (nonatomic) struct { long long width; long long height; } aspectRatio;
@property (readonly) BOOL hasCrop;
@property (readonly) BOOL cropNeedsOvercapture;
@property (readonly) unsigned long long hitVertexID;
@property (nonatomic) BOOL isAutoCrop;
@property (readonly, nonatomic) double pitchDegreeUI;
@property (readonly, nonatomic) double yawDegreeUI;
@property (readonly, nonatomic) double rollDegreeUI;

+ (struct { void /* unknown type, empty encoding */ x0[4]; })_imageTransformFromPitch:(double)a0 yaw:(double)a1 roll:(double)a2 imageRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3;
+ (struct { long long x0; long long x1; })freeFormAspectRatio;
+ (double)defaultFocalLength;

- (id)description;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })integralCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (id)initWithMasterImageSize:(struct CGSize { double x0; double x1; })a0;
- (id)initWithMasterImageRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 stitchedImageRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (void)makeCurrentFreeFormAspectFixed;
- (BOOL)imageContainsRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withTol:(double)a1;
- (struct { void /* unknown type, empty encoding */ x0[4]; })_getBoundingQuadFromPitch:(double)a0 yaw:(double)a1 roll:(double)a2 withExpansionTol:(double)a3;
- (BOOL)isEqual:(id)a0;
- (id)init;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (unsigned long long)setPitchAngle:(double)a0 constrainCropRectWithTargetArea:(double)a1;
- (unsigned long long)setYawAngle:(double)a0 constrainCropRectWithTargetArea:(double)a1;
- (unsigned long long)setRollAngle:(double)a0 constrainCropRectWithTargetArea:(double)a1;
- (void)makeCurrentAspectRatioFreeForm;
- (unsigned long long)hash;
- (void)reset;
- (unsigned long long)constrainedMoveCropRectBy:(struct CGVector { double x0; double x1; })a0 strict:(BOOL)a1 startRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2;
- (unsigned long long)setForZoomCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 newCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (unsigned long long)setRollAngle:(double)a0 constrainCropRectWithTargetArea:(double)a1 startRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 startAngle:(double)a3;
- (unsigned long long)setYawAngle:(double)a0 constrainCropRectWithTargetArea:(double)a1 startRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 startAngle:(double)a3;
- (unsigned long long)setPitchAngle:(double)a0 constrainCropRectWithTargetArea:(double)a1 startRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 startAngle:(double)a3;
- (id)initWithMasterImageRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (id)initWithMasterImageSize:(struct CGSize { double x0; double x1; })a0 fovRadians:(double)a1;
- (id)initWithMasterImageSize:(struct CGSize { double x0; double x1; })a0 stitchedImageSize:(struct CGSize { double x0; double x1; })a1;
- (id)copyWithMasterImageSize:(struct CGSize { double x0; double x1; })a0 fovRadians:(double)a1;
- (BOOL)isEqualToCropModel:(id)a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_widestCropRect;
- (void /* unknown type, empty encoding */)_defaultImageCenter;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_defaultCropRect;
- (void)_setToDefaultValues;
- (BOOL)_hasDefaultValues;
- (struct Quad2d { })_getBoundingQuad;
- (struct Quad2d { })_getBoundingQuadFromPitch:(double)a0 yaw:(double)a1 roll:(double)a2;
- (struct Quad2d { })_getBoundingQuadFromPitch:(double)a0 yaw:(double)a1 roll:(double)a2 imageRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3;
- (struct { void /* unknown type, empty encoding */ x0[4]; })_getBoundingQuadFromPitch:(double)a0 yaw:(double)a1 roll:(double)a2 withExpansionTol:(double)a3 imageRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a4;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_integralCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 straightenAngle:(double)a1 anchorPoint:(struct CGPoint { double x0; double x1; })a2;
- (void)_setCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)_setCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 anchor:(struct CGPoint { double x0; double x1; })a1;
- (void)_setCropRectWithConstantSize:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (unsigned long long)_hitMaskFromRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (unsigned long long)_hitMaskFromRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withTol:(double)a1;
- (void)_debugPrintHitMask;
- (void)_debugPrintHitMask:(unsigned long long)a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_anchorAlignedRectFromCandidate:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withAnchor:(struct CGPoint { double x0; double x1; })a1;
- (BOOL)canGrowCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 constrainWithAnchorPoint:(struct CGPoint { double x0; double x1; })a1 strict:(BOOL)a2 withTol:(double)a3;
- (unsigned long long)setCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 constrainWithAnchorPoint:(struct CGPoint { double x0; double x1; })a1;
- (unsigned long long)setCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 newCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 constrainWithAnchorPoint:(struct CGPoint { double x0; double x1; })a2;
- (unsigned long long)setCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 newCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 constrainWithAnchorPoint:(struct CGPoint { double x0; double x1; })a2 strict:(BOOL)a3;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_expandedCropRectForZoom:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 candidateRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })getCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 newCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 pitch:(double)a2 yaw:(double)a3 roll:(double)a4 constrainWithAnchorPoint:(struct CGPoint { double x0; double x1; })a5 strict:(BOOL)a6 aspectRatioIsFreeForm:(BOOL)a7 hitVertexId:(unsigned long long *)a8;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })getCropRectThatCompletelyContainsMasterImageForPitch:(double)a0 yaw:(double)a1 roll:(double)a2;
- (unsigned long long)constrainedMoveCropRectBy:(struct CGVector { double x0; double x1; })a0;
- (unsigned long long)constrainedMoveCropRectBy:(struct CGVector { double x0; double x1; })a0 strict:(BOOL)a1;
- (unsigned long long)setAspectRatio:(struct { long long x0; long long x1; })a0 constrainCropRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 withTargetArea:(double)a2;
- (double)_currentAspectAsDouble:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (struct { long long x0; long long x1; })_currentAspectRatio:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (BOOL)aspectRatioIsOriginal;
- (BOOL)aspectRatioIsFreeForm;
- (struct { long long x0; long long x1; })originalAspectRatio;

@end
