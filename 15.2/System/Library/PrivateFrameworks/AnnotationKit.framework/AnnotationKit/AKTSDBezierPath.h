@interface AKTSDBezierPath : NSObject <NSCopying, NSCoding> {
    long long sfr_elementCount;
    long long sfr_elementMax;
    struct PATHSEGMENT { unsigned char x0 : 4; unsigned long x1 : 60; struct CGPoint { double x0; double x1; } x2; } *sfr_head;
    double *sfr_elementLength;
    double sfr_totalLength;
    long long sfr_lastSubpathIndex;
    void *sfr_extraSegments;
    double sfr_lineWidth;
    struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } sfr_controlPointBounds;
    double sfr_miterLimit;
    double sfr_flatness;
    double *sfr_dashedLinePattern;
    unsigned long long sfr_dashedLineCount;
    double sfr_dashedLinePhase;
    void *sfr_path;
    long long sfr_extraSegmentCount;
    long long sfr_extraSegmentMax;
    struct { unsigned char sfr_flags : 8; unsigned char sfr_pathState : 2; unsigned char sfr_calculatedLengths : 1; unsigned int sfr_unused : 21; } sfr_bpFlags;
}

+ (void)setLineWidth:(double)a0;
+ (void)initialize;
+ (double)lineWidth;
+ (void)fillRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (double)flatness;
+ (id)bezierPathWithRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 cornerRadius:(double)a1;
+ (id)bezierPath;
+ (double)miterLimit;
+ (unsigned long long)lineCapStyle;
+ (void)setMiterLimit:(double)a0;
+ (void)setFlatness:(double)a0;
+ (id)bezierPathWithCGPath:(struct CGPath { } *)a0;
+ (unsigned long long)lineJoinStyle;
+ (void)setLineJoinStyle:(unsigned long long)a0;
+ (void)setLineCapStyle:(unsigned long long)a0;
+ (void)strokeRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)bezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (unsigned long long)windingRule;
+ (void)setWindingRule:(unsigned long long)a0;
+ (id)bezierPathWithStart:(struct CGPoint { double x0; double x1; })a0 end:(struct CGPoint { double x0; double x1; })a1;
+ (void)clipRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (void)strokeLineFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1;
+ (void)setDefaultMiterLimit:(double)a0;
+ (double)defaultMiterLimit;
+ (void)setDefaultFlatness:(double)a0;
+ (double)defaultFlatness;
+ (void)setDefaultWindingRule:(unsigned long long)a0;
+ (unsigned long long)defaultWindingRule;
+ (void)setDefaultLineCapStyle:(unsigned long long)a0;
+ (unsigned long long)defaultLineCapStyle;
+ (void)setDefaultLineJoinStyle:(unsigned long long)a0;
+ (unsigned long long)defaultLineJoinStyle;
+ (void)setDefaultLineWidth:(double)a0;
+ (double)defaultLineWidth;

- (void)setLineWidth:(double)a0;
- (void)fill;
- (double)lineWidth;
- (struct CGPath { } *)CGPath;
- (void)stroke;
- (BOOL)isFlat;
- (void)addClip;
- (double)length;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3 clockwise:(BOOL)a4;
- (void)encodeWithCoder:(id)a0;
- (double)flatness;
- (void)closePath;
- (BOOL)containsPoint:(struct CGPoint { double x0; double x1; })a0;
- (id)description;
- (unsigned long long)elementAtIndex:(long long)a0;
- (void)setLineDash:(const double *)a0 count:(long long)a1 phase:(double)a2;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })bounds;
- (double)miterLimit;
- (unsigned long long)lineCapStyle;
- (void)setMiterLimit:(double)a0;
- (BOOL)isEmpty;
- (void)setFlatness:(double)a0;
- (void)removeAllPoints;
- (void)appendBezierPath:(id)a0;
- (unsigned long long)lineJoinStyle;
- (void)setLineJoinStyle:(unsigned long long)a0;
- (void)appendBezierPathWithRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (id)bezierPathByReversingPath;
- (void)getLineDash:(double *)a0 count:(long long *)a1 phase:(double *)a2;
- (void)appendBezierPathWithOvalInRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (void)setLineCapStyle:(unsigned long long)a0;
- (void)moveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (id)init;
- (id)initWithCoder:(id)a0;
- (id)copyWithZone:(struct _NSZone { } *)a0;
- (void)lineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (id)pressure;
- (void)dealloc;
- (void)_doPath;
- (id)chisel;
- (struct CGPoint { double x0; double x1; })currentPoint;
- (long long)elementCount;
- (const char *)cString;
- (id)initWithCString:(const char *)a0;
- (void)transformUsingAffineTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0;
- (void)curveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (unsigned long long)elementAtIndex:(long long)a0 associatedPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (unsigned long long)windingRule;
- (void)setWindingRule:(unsigned long long)a0;
- (void)_deviceMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)_deviceCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (void)_deviceClosePath;
- (void)subdivideBezierWithFlatness:(double)a0 startPoint:(struct CGPoint { double x0; double x1; })a1 controlPoint1:(struct CGPoint { double x0; double x1; })a2 controlPoint2:(struct CGPoint { double x0; double x1; })a3 endPoint:(struct CGPoint { double x0; double x1; })a4;
- (void)flattenIntoPath:(id)a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })controlPointBounds;
- (unsigned long long)elementAtIndex:(long long)a0 allPoints:(struct CGPoint { double x0; double x1; } *)a1;
- (double)calculateLengthOfElement:(long long)a0;
- (void)calculateLengths;
- (void)_appendToPath:(id)a0;
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 startAngle:(double)a2 endAngle:(double)a3;
- (void)_appendArcSegmentWithCenter:(struct CGPoint { double x0; double x1; })a0 radius:(double)a1 angle1:(double)a2 angle2:(double)a3;
- (void)relativeMoveToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeLineToPoint:(struct CGPoint { double x0; double x1; })a0;
- (void)relativeCurveToPoint:(struct CGPoint { double x0; double x1; })a0 controlPoint1:(struct CGPoint { double x0; double x1; })a1 controlPoint2:(struct CGPoint { double x0; double x1; })a2;
- (id)bezierPathByFlatteningPath;
- (id)_copyFlattenedPath;
- (BOOL)isClockwise;
- (double)lengthOfElement:(long long)a0;
- (double)lengthToElement:(long long)a0;
- (void)setAssociatedPoints:(struct CGPoint { double x0; double x1; } *)a0 atIndex:(long long)a1;
- (void)appendBezierPathWithPoints:(struct CGPoint { double x0; double x1; } *)a0 count:(long long)a1;
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint { double x0; double x1; })a0 toPoint:(struct CGPoint { double x0; double x1; })a1 radius:(double)a2;
- (void)_addPathSegment:(long long)a0 point:(struct CGPoint { double x0; double x1; })a1;
- (void)getStartPoint:(struct CGPoint { double x0; double x1; } *)a0 andEndPoint:(struct CGPoint { double x0; double x1; } *)a1;
- (void)addIntersectionsWithPath:(id)a0 to:(id)a1 allIntersections:(BOOL)a2 reversed:(BOOL)a3;
- (void)appendBezierPath:(id)a0 fromSegment:(long long)a1 t:(double)a2 toSegment:(long long)a3 t:(double)a4 withoutMove:(BOOL)a5;
- (void)recursiveSubdivideOntoPath:(id)a0 withScaling:(struct { double x0; double x1; })a1 inElementRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })a2 into:(id)a3;
- (struct CGPoint { double x0; double x1; })rawGradientAt:(float)a0 fromElement:(long long)a1;
- (long long)elementPercentage:(float *)a0 forOverallPercentage:(float)a1;
- (struct CGPoint { double x0; double x1; })gradientAt:(double)a0 fromElement:(long long)a1;
- (struct CGPoint { double x0; double x1; })pointAt:(double)a0 fromElement:(long long)a1;
- (float)elementPercentageFromElement:(int)a0 forOverallPercentage:(float)a1;
- (double)curvatureAt:(double)a0 fromElement:(int)a1;
- (struct CGPoint { double x0; double x1; })transformedTotalCoordinate:(struct CGPoint { double x0; double x1; })a0 betweenElement:(long long)a1 andElement:(long long)a2 withPressure:(id)a3 getElement:(long long *)a4 getPercentage:(float *)a5;
- (struct CGPoint { double x0; double x1; })myGradientAt:(float)a0 fromElement:(long long)a1;
- (void)addIntersectionsWithPath:(id)a0 to:(id)a1;
- (void)addIntersectionsWithLine:(struct CGPoint { double x0; double x1; }[2])a0 to:(id)a1;
- (void)appendBezierPath:(id)a0 fromSegment:(long long)a1 toSegment:(long long)a2;
- (id)copyFromSegment:(int)a0 t:(float)a1 toSegment:(int)a2 t:(float)a3;
- (struct CGPoint { double x0; double x1; })nearestPointOnPathToLine:(struct CGPoint { double x0; double x1; }[2])a0;
- (struct CGPoint { double x0; double x1; })nearestAngleOnPathToLine:(struct CGPoint { double x0; double x1; }[2])a0;
- (struct CGPoint { double x0; double x1; })gradientAt:(float)a0;
- (struct CGPoint { double x0; double x1; })transformedCoordinate:(struct CGPoint { double x0; double x1; })a0 withPressure:(id)a1;
- (struct CGPoint { double x0; double x1; })transformedTotalCoordinate:(struct CGPoint { double x0; double x1; })a0 inElement:(long long)a1 withPressure:(id)a2;
- (struct CGPoint { double x0; double x1; })myGradientAt:(float)a0;
- (float)curvatureAt:(float)a0;
- (void)recursiveSubdivideOntoPath:(id)a0 into:(id)a1;
- (void)recursiveSubdivideOntoPath:(id)a0 withScaling:(struct { double x0; double x1; })a1 into:(id)a2;

@end
