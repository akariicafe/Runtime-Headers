@class NSString, NSMutableDictionary, VKLabelNavRoadGraph, NSMutableSet, NSMutableArray, VKPolylineOverlay;

@interface LabelNavRouteLabeler : NSObject {
    BOOL _isOnRoute;
    unsigned long long _stepIndex;
    BOOL _checkOnRouteLabelsAlignment;
    BOOL _disableTileParseForOneLayout;
    struct unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct __hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> **, std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { void **__value_; struct __bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { struct __compressed_pair<unsigned long, geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { unsigned long long __value_; struct StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>> { struct __hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> { void *__next_; } __value_; struct StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::hash<std::shared_ptr<md::LabelTile>>> { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::equal_to<std::shared_ptr<md::LabelTile>>> { float __value_; } __p3_; } __table_; } _tiles;
    struct unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct __hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> **, std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { void **__value_; struct __bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { struct __compressed_pair<unsigned long, geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { unsigned long long __value_; struct StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>> { struct __hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> { void *__next_; } __value_; struct StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::hash<std::shared_ptr<md::LabelTile>>> { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::equal_to<std::shared_ptr<md::LabelTile>>> { float __value_; } __p3_; } __table_; } _pendingTiles;
    NSMutableArray *_junctions;
    VKLabelNavRoadGraph *_roadGraph;
    NSMutableArray *_fadingLabels;
    NSMutableDictionary *_visibleLabelsByName;
    NSMutableArray *_visibleLabels;
    NSMutableSet *_visibleShieldGroups;
    unsigned long long _countVisibleOnRouteRoadSigns;
    unsigned long long _countVisibleOffRouteRoadSigns;
    unsigned long long _countVisibleRoadSigns;
    unsigned long long _maxVisibleOnRouteRoadSigns;
    unsigned long long _maxVisibleOffRouteRoadSigns;
    unsigned long long _maxVisibleRoadSigns;
    unsigned long long _maxOnRoadGraphRoadSigns;
    unsigned long long _minVisibleOffRoadGraphRoadSigns;
    unsigned long long _minVisibleProceedToRouteRoadSigns;
    BOOL _preferRightSideLabelPlacement;
    float _minSignOffsetDistance;
    NSMutableSet *_roadNamesInGuidance;
    NSMutableArray *_guidanceStepInfos;
    NSMutableArray *_routeRoadInfos;
    long long _currentRoadNameIndex;
    BOOL _checkIfRouteSubrangeChanged;
    BOOL _useRouteSubrange;
    BOOL _regenerateRoadSigns;
    BOOL _isStylesheetAnimating;
    struct PolylineCoordinate { unsigned int index; float offset; } _routeSubrangeStart;
    struct PolylineCoordinate { unsigned int index; float offset; } _routeSubrangeEnd;
    struct shared_ptr<md::NavCurrentRoadSign> { struct NavCurrentRoadSign *__ptr_; struct __shared_weak_count *__cntrl_; } _currentRoadSign;
    unsigned long long _debugCachedMaxVisibleOffRouteRoadSigns;
    unsigned long long _debugCachedMaxVisibleOnRouteRoadSigns;
    struct shared_ptr<gss::StylesheetManager<gss::PropertyID>> { void *__ptr_; struct __shared_weak_count *__cntrl_; } _styleManager;
    BOOL _shouldLabelOppositeCarriageways;
    struct vector<md::AvoidanceRectWithPriority, geo::StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>> { struct AvoidanceRectWithPriority *__begin_; struct AvoidanceRectWithPriority *__end_; struct __compressed_pair<md::AvoidanceRectWithPriority *, geo::StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>> { struct AvoidanceRectWithPriority *__value_; struct StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __end_cap_; } _avoidanceRects;
    BOOL _hasPendingTilesInSnappingRegion;
    BOOL _needsDebugConsoleClear;
    struct range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>>> { struct map<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>>> { struct __tree<std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, true>, std::allocator<std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<gm::Range<geo::Unit<RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, true>> { unsigned long long __value_; } __pair3_; } __tree_; } _storage; } _onRouteOrientations;
    struct range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>>> { struct map<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>>> { struct __tree<std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, true>, std::allocator<std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<gm::Range<geo::Unit<RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, true>> { unsigned long long __value_; } __pair3_; } __tree_; } _storage; } _relatedRouteOrientations;
}

@property (nonatomic) BOOL drawRoadSigns;
@property (retain, nonatomic) VKPolylineOverlay *route;
@property (retain, nonatomic) NSString *currentLocationText;
@property (retain, nonatomic) NSString *currentRoadName;
@property (retain, nonatomic) NSString *currentShieldGroup;
@property (nonatomic) struct PolylineCoordinate { unsigned int index; float offset; } routeUserOffset;
@property (readonly, nonatomic) struct vector<std::shared_ptr<md::NavLabel>, geo::StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>> { void *__begin_; void *__end_; struct __compressed_pair<std::shared_ptr<md::NavLabel> *, geo::StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>> { void *__value_; struct StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __end_cap_; } activeSigns;
@property (readonly, nonatomic) struct vector<std::shared_ptr<md::NavLabel>, geo::StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>> { void *__begin_; void *__end_; struct __compressed_pair<std::shared_ptr<md::NavLabel> *, geo::StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>> { void *__value_; struct StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __end_cap_; } visibleSigns;
@property (readonly, nonatomic) BOOL needsLayout;
@property (readonly, nonatomic) void *currentRoadSign;
@property (readonly, nonatomic) float currentRoadSignPixelHeight;
@property (nonatomic) BOOL debugDisableRoadSignLimit;
@property (nonatomic) BOOL debugEnableShieldsOnRouteLine;
@property (nonatomic) void *artworkCache;

- (void)_tryAddRoadSignForJunction:(id)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 labelCollisionEnabled:(BOOL)a2;
- (void)_updateCurrentRoadInfo;
- (void)_createOrUpdateLabelForRoad:(id)a0 isShield:(BOOL)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2 hopOffsetDistance:(float)a3;
- (void)_tryAddRoadSignForRoad:(id)a0 isShield:(BOOL)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2 labelCollisionEnabled:(BOOL)a3;
- (void)_initalizeCurrentRoadInfo;
- (BOOL)_collideLabel:(id)a0 activeLabel:(id)a1 labelsToRemove:(id)a2;
- (void)styleManagerDidFinishAnimating;
- (unsigned char)orientationForRoadSign:(id)a0 roadLabel:(id)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2;
- (void)drawRoadSignOrientationDebugView:(void *)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1;
- (void)styleManagerDidStartAnimating;
- (void)_updateRoadStarts;
- (unsigned char)computeRoutePositionForPOIAtPixel:(const void *)a0 currentPosition:(unsigned char)a1 context:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2;
- (void)setMaxVisibleRoadsigns:(unsigned int)a0;
- (void)_updatePreferredLabelPlacements;
- (BOOL)_addJunctionsForTile:(const void *)a0;
- (void)_generateCurrentRoadSignWithContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0;
- (void)_addLabelsAtJunctions:(id)a0 withContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 maxLabelsToAdd:(unsigned long long)a2;
- (BOOL)isNavMode;
- (void)drawNavOverlayDebugView:(void *)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1;
- (void)layoutWithNavContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0 avoidanceRects:(const void *)a1;
- (void)_reloadRouteJunctions;
- (void)_refreshGuidanceRoadNames;
- (void)setStyleManager:(struct shared_ptr<gss::StylesheetManager<gss::PropertyID>> { void *x0; struct __shared_weak_count *x1; })a0;
- (void)grabTilesFromScene:(const void *)a0;
- (void)_addLabelsForJunctions:(id)a0 withContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 maxLabelsToAdd:(unsigned long long)a2 useAllJunctions:(BOOL)a3 placeShieldsFrontToBack:(BOOL)a4;
- (void)_addVisibleSigns;
- (void).cxx_destruct;
- (id)init;
- (void)_dedupOffRouteRoads;
- (BOOL)_findRouteOverlappingJunctionFrom:(long long)a0 routeJunctions:(void *)a1 lookBackward:(BOOL)a2 firstOverlap:(long long *)a3 secondOverlap:(long long *)a4;
- (void)_tryAddLabel:(id)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1 labelCollisionEnabled:(BOOL)a2;
- (void)_updateUniqueOffRouteRoads;
- (BOOL)_updateActiveRouteRange;
- (struct optional<md::RoadSignOrientationResolver> { BOOL x0; union ValueUnion { unsigned char x0[24]; struct RoadSignOrientationResolver { void *x0; struct Unit<RadianUnitDescription, float> { float x0; } x1; struct Unit<RadianUnitDescription, float> { float x0; } x2; unsigned char x3; } x1; } x1; })createRoadSignOrientationResolver:(id)a0 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a1;
- (BOOL)needsDebugDraw;
- (unsigned char)resolveOrientation:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a0 road:(id)a1 currentOrientation:(unsigned char)a2;
- (void)styleManagerDidChange:(BOOL)a0;
- (void)dealloc;
- (id).cxx_construct;
- (void)debugDraw:(id)a0 overlayConsole:(void *)a1 navContext:(struct NavContext { void /* function */ **x0; struct LabelManager *x1; struct MapNavLabeler *x2; struct LabelLayoutContext *x3; struct LabelNavLayoutContext *x4; } *)a2;
- (void)_updateRoadsInGuidance;
- (void)clearSceneIsMemoryWarning:(BOOL)a0;

@end
