@class NSMutableDictionary, ARWorldTrackingErrorData, NSObject, ARWorldTrackingOptions, ARSceneReconstructionHandler, NSMutableArray, ARWorldTrackingPoseData, NSString, NSHashTable, NSMutableSet, deterministicMode, ARTrackedRaycastPostProcessor, NSNumber;
@protocol OS_dispatch_queue, MTLDevice, OS_dispatch_semaphore, MTLCommandQueue, MTLFunction;

@interface ARWorldTrackingTechnique : ARImageBasedTechnique <ARSceneReconstructionDelegate> {
    NSHashTable *_observers;
    NSObject<OS_dispatch_semaphore> *_observersSemaphore;
    struct map<long, double, std::less<long>, std::allocator<std::pair<const long, double>>> { struct __tree<std::__value_type<long, double>, std::__map_value_compare<long, std::__value_type<long, double>, std::less<long>, true>, std::allocator<std::__value_type<long, double>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<long, double>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<long, std::__value_type<long, double>, std::less<long>, true>> { unsigned long long __value_; } __pair3_; } __tree_; } _lastErrorLogTimestamp;
    BOOL _useFixedIntrinsics;
    long long _sessionHandleState;
    NSObject<OS_dispatch_semaphore> *_sessionHandleStateSemaphore;
    ARWorldTrackingErrorData *_errorData;
    ARWorldTrackingPoseData *_cachedPoseData;
    double _lastPoseMetaDataTimestamp;
    int _reinitializationAttempts;
    unsigned long long _numberOfCameraSwitches;
    unsigned long long _currentVIOMapSize;
    long long _reinitializationAttemptsAtInitialization;
    double _lastRelocalizationTimestamp;
    double _lastQualityKeyframeTimestamp;
    int _previousKeyframeCount;
    double _lastPoseTrackingMapTimestamp;
    double _lastMajorRelocalizationTimestamp;
    double _originTimestamp;
    NSString *_lastCameraType;
    unsigned int _primaryCameraID;
    BOOL _relocalizingAfterSensorDataDrop;
    BOOL _didClearMap;
    NSObject<OS_dispatch_semaphore> *_resultSemaphore;
    double _minVergenceAngleCosine;
    double _resultLatency;
    BOOL _allowPoseGraphUpdates;
    struct PlaneDetectionConfiguration { ARWorldTrackingOptions *options; NSNumber *detectionCountUserDefaultValue; NSNumber *minVergenceAngleDegreesUserDefaultValue; deterministicMode *lineFeaturesAlwaysOnUserDefaultValue; BOOL x0; NSString *detectionPolicyString; } _surfaceDetectionParametrization;
    NSMutableSet *_anchorsReceived;
    NSMutableSet *_participantAnchors;
    BOOL _participantAnchorsEnabled;
    struct __CVPixelBufferPool { } *_depth16grayBufferPool;
    struct __CVPixelBufferPool { } *_confidence8BufferPool;
    struct __CVPixelBufferPool { } *_postProcessedDepthConfidencePool;
    NSMutableArray *_latestSpatialMappingData;
    struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } _latestSpatialMappingDataLock;
    NSMutableDictionary *_meshChunksWaitingForSemantics;
    NSMutableDictionary *_meshChunkIdentifiersCurrentlyBeingProcessed;
    struct os_unfair_lock_s { unsigned int _os_unfair_lock_opaque; } _volumeSamplingLock;
    id<MTLCommandQueue> _spatialMappingCommandQueue;
    id<MTLDevice> _sharedMetalDevice;
    struct __CVPixelBufferPool { } *_poolForSemanticsAnnotatedDepth;
    struct __CVPixelBufferPool { } *_poolForUncertaintyAnnotatedDepth;
    struct __CVPixelBufferPool { } *_poolForConfidenceAnnotatedDepth;
    struct __CVPixelBufferPool { } *_poolForUncertaintyMaskedSemanticsDepth;
    id<MTLFunction> _annotateDepthDataKernelFunction;
    NSMutableDictionary *_spatialMappingResultDataWaitingForSemantics;
    NSObject<OS_dispatch_queue> *_spatialMappingObjectRefinementQueue;
    NSObject<OS_dispatch_queue> *_resultDataQueue;
}

@property unsigned long long techniqueIndex;
@property (retain) ARWorldTrackingOptions *mutableOptions;
@property struct { void /* unknown type, empty encoding */ columns[4]; } referenceOriginTransform;
@property (nonatomic) struct CV3DSLAMSession { } *slamSessionHandle;
@property (nonatomic) struct CV3DPosePredictionContext { } *predictorHandle;
@property (nonatomic) struct shared_ptr<RaycastSession> { struct RaycastSession *__ptr_; struct __shared_weak_count *__cntrl_; } raycastSession;
@property (nonatomic) struct shared_ptr<PlaneDetectionSession> { struct PlaneDetectionSession *__ptr_; struct __shared_weak_count *__cntrl_; } planeDetectionSession;
@property (nonatomic) struct { void /* unknown type, empty encoding */ columns[4]; } reconstructionFrameBundleToWorld;
@property (readonly) unsigned long long vioSessionIdentifier;
@property BOOL hasQualityKeyframe;
@property (retain) ARTrackedRaycastPostProcessor *trackedRaycastPostProcessor;
@property struct { void /* unknown type, empty encoding */ columns[4]; } extrinsicsToWideSensor;
@property (readonly, nonatomic) ARSceneReconstructionHandler *sceneReconstructionHandler;
@property (readonly, copy, nonatomic) ARWorldTrackingOptions *options;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;

+ (BOOL)isSupported;
+ (BOOL)producesResultDataForAnchorOfClass:(Class)a0;
+ (BOOL)supportsVideoResolution:(struct CGSize { double x0; double x1; })a0 forDeviceType:(id)a1;

- (id)processData:(id)a0;
- (id)initWithOptions:(id)a0;
- (void)addObserver:(id)a0;
- (void)invalidateAllRaycasts;
- (void)removeObserver:(id)a0;
- (void).cxx_destruct;
- (BOOL)isEqual:(id)a0;
- (id)init;
- (void)dealloc;
- (void)prepare:(BOOL)a0;
- (id)_fullDescription;
- (id).cxx_construct;
- (void)_didFailWithError:(id)a0;
- (void)pushCollaborationData:(id)a0;
- (void)requestResultDataAtTimestamp:(double)a0 context:(id)a1;
- (double)requiredTimeInterval;
- (id)resultDataClasses;
- (void)stopRaycast:(id)a0;
- (unsigned long long)requiredSensorDataTypes;
- (BOOL)reconfigurableFrom:(id)a0;
- (void)reconfigureFrom:(id)a0;
- (void)prepareResultData:(id)a0 forContext:(id)a1;
- (BOOL)deterministicMode;
- (long long)captureBehavior;
- (id)predictedResultDataAtTimestamp:(double)a0 context:(id)a1;
- (void)mergeResultData:(id)a0 intoData:(id)a1 context:(id)a2;
- (long long)vioHandleState;
- (void)_initializeSurfaceDetection:(const struct PlaneDetectionConfiguration { id x0; id x1; id x2; id x3; BOOL x4; id x5; } *)a0;
- (void)updateSurfaceDetectionConfiguration;
- (void)setupSceneReconstruction;
- (void)_configureMeshPlaneHarmonization;
- (void)_updateVIOLineDetectionPolicy;
- (id)getObservers;
- (long long)_initializeSLAMAndPredictorHandle;
- (int)_updatePoseData:(id)a0 forTimeStamp:(double)a1 updateTrackingState:(BOOL)a2;
- (void)_pushWTResultDataForTimestamp:(double)a0;
- (void)annotateDepth:(id)a0 withSemantics:(id)a1 toTargetSemanticsImage:(struct __CVBuffer { } *)a2 targetConfidenceBuffer:(struct __CVBuffer { } *)a3 targetUncertaintyBuffer:(struct __CVBuffer { } *)a4;
- (void)pushToSceneUnderstandingDepth:(id)a0 segmentation:(id)a1 pose:(id)a2;
- (void)pushToSceneUnderstandingSegmentation:(id)a0 pose:(id)a1;
- (void)pushToHitTestingDepth:(id)a0 pose:(id)a1;
- (void)annotateDepth:(id)a0 withSemantics:(id)a1 toTargetSemanticsImage:(struct __CVBuffer { } *)a2 targetConfidenceBuffer:(struct __CVBuffer { } *)a3 targetUncertaintyBuffer:(struct __CVBuffer { } *)a4 useGpu:(BOOL)a5;
- (void)_handleCV3DError:(struct __CFError { } *)a0 withDescription:(id)a1 failTechnique:(BOOL)a2;
- (void)resetSceneReconstruction;
- (int)extentCheckFromConfiguration;
- (id)raycastResultFrom:(struct CV3DHitTestResult { struct __CFUUID *x0; double x1[16]; int x2; int x3; int x4; struct __CFUUID *x5; } *)a0;
- (void)onMetadataCallback:(struct CV3DSLAMStateContext { } *)a0;
- (void)_handleSLAMError:(id)a0;
- (void)_handleRaycastResultCallback:(struct CV3DRaycastResultMap { } *)a0;
- (void)_reportCollaborationData:(id)a0 type:(unsigned char)a1 metadata:(const void *)a2;
- (BOOL)isMultiSessionMode;
- (void)_handlePlaneDetectionCallback:(struct CV3DPlaneDetectionPlaneList { } *)a0;
- (unsigned int)_trackingCameraID:(struct CV3DSLAMStateContext { } *)a0;
- (void)_updateTrackingState:(id)a0 slamState:(const struct CV3DSLAMStateContext { } *)a1;
- (long long)_mappingStatusFromMapSize:(int)a0 keyframeQuality:(int)a1 isTrackingMap:(BOOL)a2 timestamp:(double)a3;
- (id)_featurePointDataFromSLAMState:(const struct CV3DSLAMStateContext { } *)a0;
- (void)sceneReconstructionHandler:(id)a0 didOutputMeshList:(const struct CV3DReconMeshList { } *)a1 withTimestamp:(double)a2;
- (void)sceneReconstructionHandler:(id)a0 didFailWithError:(id)a1;
- (id)serializeWorldMapWithReferenceOrigin:(struct { void /* unknown type, empty encoding */ x0[4]; })a0;
- (void)clearMap;
- (id)serializeSurfaceData;
- (void)loadSurfaceData:(id)a0;
- (void)addReferenceAnchors:(id)a0;
- (void)removeReferenceAnchors:(id)a0;
- (void)removePlanesByUUIDs:(id)a0;
- (id)raycast:(id)a0;
- (id)trackedRaycast:(id)a0 updateHandler:(id /* block */)a1;
- (void)stopAllRaycasts;
- (void)didUpdateRaycastResult:(struct CV3DHitTestResults { struct CV3DHitTestResult *x0; unsigned long long x1; } *)a0;
- (BOOL)querySceneReconstructionOccupancyWithPoints:(id)a0 callback:(id /* block */)a1;

@end
