@class AKPageController;

@interface AKGeometryHelper : NSObject

@property (weak) AKPageController *pageController;

+ (double)lengthOfVector:(struct CGVector { double x0; double x1; })a0;
+ (struct CGVector { double x0; double x1; })normalizeVector:(struct CGVector { double x0; double x1; })a0;
+ (struct CGPoint { double x0; double x1; })normalizeVectorPoint:(struct CGPoint { double x0; double x1; })a0;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })horizontalFlipTransformForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (BOOL)annotationHasRotation:(id)a0 outAngle:(double *)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })boundsOfRotatedRectangle:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 angle:(double)a1;
+ (double)distanceBetweenPoints:(struct CGPoint { double x0; double x1; })a0 andPoint:(struct CGPoint { double x0; double x1; })a1;
+ (unsigned long long)draggableArea:(unsigned long long)a0 convertedForExif:(long long)a1;
+ (BOOL)exifOrientationHasReversedAxes:(long long)a0;
+ (struct CGPoint { double x0; double x1; })intersectRayStartingAt:(struct CGPoint { double x0; double x1; })a0 ending:(struct CGPoint { double x0; double x1; })a1 withEllipseOfRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 farthestResult:(BOOL)a3;
+ (struct CGPoint { double x0; double x1; })projectVector:(struct CGPoint { double x0; double x1; })a0 ontoAspectVector:(struct CGPoint { double x0; double x1; })a1;
+ (struct CGPoint { double x0; double x1; })_alignedPointForPoint:(struct CGPoint { double x0; double x1; })a0 alignToContent:(BOOL)a1 alignToScreenUsingPageController:(id)a2 orAlignToBitmapContext:(struct CGContext { } *)a3 usingAnnotation:(id)a4;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_alignedStableRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 alignToContent:(BOOL)a1 alignToScreenUsingPageController:(id)a2 orAlignToBitmapContext:(struct CGContext { } *)a3 usingAnnotation:(id)a4;
+ (void)_checkIntersectionOfLineSegmentStartingAt:(struct CGPoint { double x0; double x1; })a0 endingAt:(struct CGPoint { double x0; double x1; })a1 withCircleAt:(struct CGPoint { double x0; double x1; })a2 andRadius:(double)a3 results:(id)a4;
+ (void)_collectIntersectionsOfLineSegmentStartingAt:(struct CGPoint { double x0; double x1; })a0 endingAt:(struct CGPoint { double x0; double x1; })a1 withCornerCirclesOfRoundedRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 withRadius:(double)a3 results:(id)a4;
+ (id)_cornersOfRotatedRectangle:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 angle:(double)a1;
+ (struct CGPoint { double x0; double x1; })_farthestPointFrom:(struct CGPoint { double x0; double x1; })a0 inArray:(id)a1;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })_rawAffineTransformForExifOrientation:(long long)a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_rectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 alignToContent:(BOOL)a1 alignToScreenUsingPageController:(id)a2 orAlignToBitmapContext:(struct CGContext { } *)a3 usingAnnotation:(id)a4 withAlignmentBlock:(id /* block */)a5;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_strokeAlignedRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withStrokeWidth:(double)a1 shouldAlignStrictlyToScreen:(BOOL)a2 alignToScreenUsingPageController:(id)a3 orAlignToBitmapContext:(struct CGContext { } *)a4 usingAnnotation:(id)a5;
+ (void)adjustOriginalExifOrientationOnAnnotation:(id)a0 flatteningOriginalModelExif:(long long)a1;
+ (struct CGPoint { double x0; double x1; })adjustPoint:(struct CGPoint { double x0; double x1; })a0 forExifOrientation:(long long)a1 aboutCenter:(struct CGPoint { double x0; double x1; })a2;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })adjustRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 forExifOrientation:(long long)a1 aboutCenter:(struct CGPoint { double x0; double x1; })a2;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })affineTransformFlatteningOriginalModelExif:(long long)a0 withOriginalModelSize:(struct CGSize { double x0; double x1; })a1;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })affineTransformForExifOrientation:(long long)a0 aboutCenter:(struct CGPoint { double x0; double x1; })a1;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })affineTransformRecenteringAboutOriginForExifOrientation:(long long)a0 withOriginalSize:(struct CGSize { double x0; double x1; })a1;
+ (double)angleBetweenPoint:(struct CGPoint { double x0; double x1; })a0 andPoint:(struct CGPoint { double x0; double x1; })a1;
+ (double)angleOfVector:(struct CGVector { double x0; double x1; })a0;
+ (struct CGPoint { double x0; double x1; })centerOfRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })centeredCircleToEllipseTransform:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (struct CGPoint { double x0; double x1; })compareVectorDirectionsFirstVector:(struct CGPoint { double x0; double x1; })a0 secondVector:(struct CGPoint { double x0; double x1; })a1;
+ (long long)concatExifOrientation:(long long)a0 withExifOrientation:(long long)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })constrainRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withinRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
+ (struct CGPoint { double x0; double x1; })convertModelToScreenOrientationForPoint:(struct CGPoint { double x0; double x1; })a0 relativeToRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 withPageController:(id)a2;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })convertModelToScreenOrientationForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withPageController:(id)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })convertRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 fromScreenPointsToView:(id)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })convertRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 fromViewToScreenPixels:(id)a1 useNativeScale:(BOOL)a2;
+ (struct CGPoint { double x0; double x1; })convertScreenToModelOrientationForPoint:(struct CGPoint { double x0; double x1; })a0 relativeToRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 withPageController:(id)a2;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })convertScreenToModelOrientationForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withPageController:(id)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })effectiveDrawingBoundsForAnnotation:(id)a0 forDisplay:(BOOL)a1 pageControllerOrNil:(id)a2 outScaleFactor:(double *)a3;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })ellipseToCenteredCircleTransform:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (BOOL)exifOrientationHasFlip:(long long)a0;
+ (long long)exifOrientationWithConversionBlock:(id /* block */)a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })expandCGRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 toContainPoint:(struct CGPoint { double x0; double x1; })a1;
+ (struct CGPoint { double x0; double x1; })flipPointVertically:(struct CGPoint { double x0; double x1; })a0 inRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })integralRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withOptions:(unsigned long long)a1;
+ (void)intersectCircleAtPoint:(struct CGPoint { double x0; double x1; })a0 withRadius:(double)a1 withCircleAtPoint:(struct CGPoint { double x0; double x1; })a2 withRadius:(double)a3 firstOutPoint:(struct CGPoint { double x0; double x1; } *)a4 secondOutPoint:(struct CGPoint { double x0; double x1; } *)a5;
+ (struct CGPoint { double x0; double x1; })intersectLineSegmentStartingAt:(struct CGPoint { double x0; double x1; })a0 ending:(struct CGPoint { double x0; double x1; })a1 withAnotherSegmentStartingAt:(struct CGPoint { double x0; double x1; })a2 ending:(struct CGPoint { double x0; double x1; })a3;
+ (struct CGPoint { double x0; double x1; })intersectLineSegmentStartingAt:(struct CGPoint { double x0; double x1; })a0 ending:(struct CGPoint { double x0; double x1; })a1 withCircleWithCenter:(struct CGPoint { double x0; double x1; })a2 andRadius:(double)a3 farthestResult:(BOOL)a4;
+ (struct CGPoint { double x0; double x1; })intersectLineSegmentStartingAt:(struct CGPoint { double x0; double x1; })a0 ending:(struct CGPoint { double x0; double x1; })a1 withEllipseOfRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 farthestResult:(BOOL)a3;
+ (struct CGPoint { double x0; double x1; })intersectLineSegmentStartingAt:(struct CGPoint { double x0; double x1; })a0 ending:(struct CGPoint { double x0; double x1; })a1 withRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 andRoundedCornerRadius:(double)a3;
+ (struct CGPoint { double x0; double x1; })intersectRayStartingAt:(struct CGPoint { double x0; double x1; })a0 ending:(struct CGPoint { double x0; double x1; })a1 withCircleWithCenter:(struct CGPoint { double x0; double x1; })a2 andRadius:(double)a3 farthestResult:(BOOL)a4;
+ (long long)inverseExifOrientation:(long long)a0;
+ (BOOL)isPoint:(struct CGPoint { double x0; double x1; })a0 onEllipse:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
+ (BOOL)isPointOnLeft:(struct CGPoint { double x0; double x1; })a0 ofRayWithFirstPoint:(struct CGPoint { double x0; double x1; })a1 andSecondPoint:(struct CGPoint { double x0; double x1; })a2;
+ (BOOL)isUnpresentablePoint:(struct CGPoint { double x0; double x1; })a0;
+ (BOOL)isUnpresentableRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (BOOL)isUnpresentableSize:(struct CGSize { double x0; double x1; })a0;
+ (struct CGPath { } *)newPathWithPath:(struct CGPath { } *)a0 applyingExifOrientation:(long long)a1 aboutCenter:(struct CGPoint { double x0; double x1; })a2;
+ (struct CGPoint { double x0; double x1; })pointAtAngle:(double)a0 inCircleWithCenter:(struct CGPoint { double x0; double x1; })a1 andRadius:(double)a2;
+ (struct CGPoint { double x0; double x1; })projectPoint:(struct CGPoint { double x0; double x1; })a0 ontoRayWithFirstPoint:(struct CGPoint { double x0; double x1; })a1 andSecondPoint:(struct CGPoint { double x0; double x1; })a2;
+ (double)radiusOfCenteredCircleFor:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })rectForSize:(struct CGSize { double x0; double x1; })a0 inRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1;
+ (BOOL)rectHasZeroSize:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })rectWithSize:(struct CGSize { double x0; double x1; })a0 centeredAtPoint:(struct CGPoint { double x0; double x1; })a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })renderingAlignedTextRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 alignToScreenUsingPageController:(id)a1 orAlignToContext:(struct CGContext { } *)a2 usingAnnotation:(id)a3;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })renderingStrokeAlignedRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withStrokeWidth:(double)a1 alignToScreenUsingPageController:(id)a2 orAlignToContext:(struct CGContext { } *)a3 usingAnnotation:(id)a4;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })rotationTransformAroundPoint:(struct CGPoint { double x0; double x1; })a0 withAngle:(double)a1;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })rotationTransformForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withAngle:(double)a1;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })rotationTransformForRectangularAnnotation:(id)a0 hasRotation:(BOOL *)a1;
+ (double)scaleOfTransform:(struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })a0;
+ (struct CGPoint { double x0; double x1; })snapVector:(struct CGPoint { double x0; double x1; })a0 toDiagonalForAspectRatio:(double)a1 ignoreWidth:(BOOL)a2 ignoreHeight:(BOOL)a3;
+ (struct CGPoint { double x0; double x1; })snapVectorTo45Degrees:(struct CGPoint { double x0; double x1; })a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })stableIntegralRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (struct CGPoint { double x0; double x1; })tangentOfEllipse:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 throughRayWithFirstPoint:(struct CGPoint { double x0; double x1; })a1 goingThrough:(struct CGPoint { double x0; double x1; })a2;
+ (void)tangentPointsToEllipse:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 fromPoint:(struct CGPoint { double x0; double x1; })a1 firstOutPoint:(struct CGPoint { double x0; double x1; } *)a2 secondOutPoint:(struct CGPoint { double x0; double x1; } *)a3;
+ (struct CGAffineTransform { double x0; double x1; double x2; double x3; double x4; double x5; })verticalFlipTransformForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (id)verticesOfPolygonWithPointCount:(unsigned long long)a0 inRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 rotation:(double)a2 flippedVertically:(BOOL)a3;

- (id)initWithPageController:(id)a0;
- (void).cxx_destruct;
- (id)_rootLayer;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_clippingFrameForView:(id)a0;
- (BOOL)_shouldAlignToContent;
- (BOOL)_shouldAlignToScreen;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })_smartAlignedRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })adornmentLayerFrameForAnnotation:(id)a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })annotationLayerFrameForAnnotation:(id)a0 layerIsClipped:(BOOL *)a1;
- (struct CGPoint { double x0; double x1; })contentAlignedPointForPoint:(struct CGPoint { double x0; double x1; })a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })contentAlignedRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (struct CGPoint { double x0; double x1; })convertPoint:(struct CGPoint { double x0; double x1; })a0 fromModelToLayer:(id)a1;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })convertRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 fromModelToLayer:(id)a1;
- (struct CGPoint { double x0; double x1; })screenPixelAlignedPointForPoint:(struct CGPoint { double x0; double x1; })a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })screenPixelAlignedRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
- (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })screenStrokeAlignedRectForRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 withStrokeWidth:(double)a1;

@end
