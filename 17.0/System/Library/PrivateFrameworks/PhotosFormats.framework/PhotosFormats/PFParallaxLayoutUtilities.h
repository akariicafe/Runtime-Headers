@interface PFParallaxLayoutUtilities : NSObject

+ (BOOL)_rectIsValid:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })bestFaceRectWithImageSize:(struct CGSize { double x0; double x1; })a0 deviceSize:(struct CGSize { double x0; double x1; })a1 faceRegions:(id)a2;
+ (unsigned long long)clockIntersectionFromTopRectMatteCoverage:(double)a0 bottomRectMatteCoverage:(double)a1;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })computeInactiveAvoidingRectForVisibleRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 acceptableFrame:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 unsafeRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 imageSize:(struct CGSize { double x0; double x1; })a3 considerHeadroom:(BOOL)a4 newVisibleRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } *)a5;
+ (id)computeLayoutWithHelper:(id)a0;
+ (id)computeLayoutsWithHelper:(id)a0;
+ (double)cropScoreThresholdForClassification:(unsigned long long)a0;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })effectiveAcceptableRectForClassification:(unsigned long long)a0 havePetFaces:(BOOL)a1 sourcePreferredCropRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 sourceAcceptableCropRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3 sourceFaceAreaRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a4 sourceGazeAreaRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a5;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })effectiveMatteInspectionRectForClassification:(unsigned long long)a0 havePetFaces:(BOOL)a1 sourceAcceptableCropRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 sourceFaceAreaRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3 sourcePreferredRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a4 originalMatteRectDenormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a5;
+ (struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })effectivePreferredRectForClassification:(unsigned long long)a0 havePetFaces:(BOOL)a1 sourcePreferredCropRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a2 sourceAcceptableCropRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a3 sourceFaceAreaRectNormalized:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a4;
+ (BOOL)facePositionAcceptable:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 imageAspect:(double)a1;
+ (struct { double x0; double x1; double x2; double x3; double x4; double x5; })facePositionLimits;
+ (float)headroomPenaltyForIntermediateLayout:(id)a0 originalFullExtent:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a1 layoutConfiguration:(id)a2;
+ (unsigned long long)layoutTypeFromLayoutConfiguration:(id)a0;
+ (double)timeOverlapCheckThresholdForTopRect:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })a0 isInteractive:(BOOL)a1;

@end
